<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Voxel World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
        }
        #inventory {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        .inv-slot {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
        }
        .inv-slot.active {
            border-color: white;
            background: rgba(255,255,255,0.2);
        }
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.3);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        .control-btn:active {
            background: rgba(255,255,255,0.5);
        }
        #joystick {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            border-radius: 50%;
            z-index: 100;
            display: none;
        }
        #joystick-handle {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.5);
            border: 2px solid white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.8);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        @media (max-width: 768px) {
            #mobile-controls, #joystick {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>FPS: <span id="fps">60</span></div>
        <div>Position: <span id="pos">0, 0, 0</span></div>
        <div>Chunks: <span id="chunks">0</span></div>
    </div>
    <div id="crosshair"></div>
    <div id="inventory"></div>
    <div id="joystick">
        <div id="joystick-handle"></div>
    </div>
    <div id="mobile-controls">
        <div class="control-btn" id="jump-btn">â†‘</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        if (isMobile) {
            document.getElementById('mobile-controls').style.display = 'flex';
            document.getElementById('joystick').style.display = 'block';
        }

        const BLOCKS = {
            GRASS: { name: 'Grass', color: 0x4CAF50, top: 0x7CB342, bottom: 0x5D4037 },
            DIRT: { name: 'Dirt', color: 0x8D6E63 },
            STONE: { name: 'Stone', color: 0x757575 },
            WOOD: { name: 'Wood', color: 0x8B4513 },
            LEAVES: { name: 'Leaves', color: 0x228B22 },
            SAND: { name: 'Sand', color: 0xF4A460 }
        };

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 30, 80);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(50, 100, 50);
        scene.add(dirLight);

        // World settings
        const chunkSize = 16;
        const renderDistance = 2;
        const worldHeight = 20;
        const world = new Map();
        
        // Materials
        const materials = {};
        for (const [key, data] of Object.entries(BLOCKS)) {
            materials[key] = new THREE.MeshLambertMaterial({ 
                color: data.color
            });
        }

        // Player
        const player = {
            position: new THREE.Vector3(0, 20, 0),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: 0 },
            height: 1.8,
            radius: 0.3,
            onGround: false,
            selectedBlock: 'GRASS'
        };

        camera.position.copy(player.position);

        // Input
        const keys = {};
        let joystickDelta = { x: 0, y: 0 };

        // Noise functions
        function hash(x, y) {
            let h = x * 374761393 + y * 668265263;
            h = (h ^ (h >>> 13)) * 1274126177;
            return (h ^ (h >>> 16)) / 4294967296;
        }

        function noise(x, z) {
            const xi = Math.floor(x);
            const zi = Math.floor(z);
            const xf = x - xi;
            const zf = z - zi;
            
            const a = hash(xi, zi);
            const b = hash(xi + 1, zi);
            const c = hash(xi, zi + 1);
            const d = hash(xi + 1, zi + 1);
            
            const u = xf * xf * (3 - 2 * xf);
            const v = zf * zf * (3 - 2 * zf);
            
            return a * (1 - u) * (1 - v) + b * u * (1 - v) + c * (1 - u) * v + d * u * v;
        }

        function getBlockType(x, y, z) {
            const height = Math.floor(12 + noise(x * 0.05, z * 0.05) * 5 + noise(x * 0.15, z * 0.15) * 2);
            if (y > height) return null;
            if (y === height) return height < 10 ? 'SAND' : 'GRASS';
            if (y > height - 3) return height < 10 ? 'SAND' : 'DIRT';
            return 'STONE';
        }

        function getBlockKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        function getChunkKey(cx, cz) {
            return `${cx},${cz}`;
        }

        // OPTIMIZED: Merge all blocks in a chunk into single geometry
        function createMergedChunkMesh(blocks, chunkX, chunkZ) {
            const geometries = {};
            
            for (const blockType of Object.keys(BLOCKS)) {
                geometries[blockType] = [];
            }
            
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const tempMatrix = new THREE.Matrix4();
            
            blocks.forEach(({ x, y, z, type }) => {
                // Only add faces that are visible (greedy meshing lite)
                const hasTop = !world.has(getBlockKey(x, y + 1, z));
                const hasBottom = !world.has(getBlockKey(x, y - 1, z));
                const hasNorth = !world.has(getBlockKey(x, y, z + 1));
                const hasSouth = !world.has(getBlockKey(x, y, z - 1));
                const hasEast = !world.has(getBlockKey(x + 1, y, z));
                const hasWest = !world.has(getBlockKey(x - 1, y, z));
                
                // If completely surrounded, skip
                if (!hasTop && !hasBottom && !hasNorth && !hasSouth && !hasEast && !hasWest) {
                    return;
                }
                
                tempMatrix.makeTranslation(x, y, z);
                const clonedGeo = boxGeo.clone();
                clonedGeo.applyMatrix4(tempMatrix);
                geometries[type].push(clonedGeo);
            });
            
            const meshes = [];
            for (const [type, geos] of Object.entries(geometries)) {
                if (geos.length > 0) {
                    const mergedGeo = mergeGeometries(geos);
                    
                    if (mergedGeo) {
                        const mesh = new THREE.Mesh(mergedGeo, materials[type]);
                        mesh.userData = { chunkX, chunkZ, type };
                        meshes.push(mesh);
                    }
                }
            }
            
            return meshes;
        }
        
        // Fallback geometry merger
        function mergeGeometries(geometries) {
            if (geometries.length === 0) return null;
            
            let totalVertices = 0;
            let totalIndices = 0;
            
            geometries.forEach(geo => {
                totalVertices += geo.attributes.position.count;
                if (geo.index) totalIndices += geo.index.count;
            });
            
            const positions = new Float32Array(totalVertices * 3);
            const normals = new Float32Array(totalVertices * 3);
            const indices = new Uint16Array(totalIndices);
            
            let vertexOffset = 0;
            let indexOffset = 0;
            let vertexCount = 0;
            
            geometries.forEach(geo => {
                const pos = geo.attributes.position.array;
                const norm = geo.attributes.normal.array;
                
                positions.set(pos, vertexOffset);
                normals.set(norm, vertexOffset);
                vertexOffset += pos.length;
                
                if (geo.index) {
                    const idx = geo.index.array;
                    for (let i = 0; i < idx.length; i++) {
                        indices[indexOffset + i] = idx[i] + vertexCount;
                    }
                    indexOffset += idx.length;
                }
                
                vertexCount += geo.attributes.position.count;
            });
            
            const mergedGeo = new THREE.BufferGeometry();
            mergedGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            mergedGeo.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
            mergedGeo.setIndex(new THREE.BufferAttribute(indices, 1));
            
            return mergedGeo;
        }

        // Chunk management
        const chunks = new Map();

        function createChunk(cx, cz) {
            const chunkKey = getChunkKey(cx, cz);
            if (chunks.has(chunkKey)) return;
            
            const startX = cx * chunkSize;
            const startZ = cz * chunkSize;
            const blocks = [];
            
            // Generate blocks
            for (let x = startX; x < startX + chunkSize; x++) {
                for (let z = startZ; z < startZ + chunkSize; z++) {
                    for (let y = 0; y < worldHeight; y++) {
                        const blockType = getBlockType(x, y, z);
                        if (blockType) {
                            const key = getBlockKey(x, y, z);
                            world.set(key, blockType);
                            blocks.push({ x, y, z, type: blockType });
                        }
                    }
                }
            }
            
            // Create merged meshes
            const meshes = createMergedChunkMesh(blocks, cx, cz);
            chunks.set(chunkKey, meshes);
            meshes.forEach(mesh => scene.add(mesh));
        }

        function removeChunk(cx, cz) {
            const chunkKey = getChunkKey(cx, cz);
            const meshes = chunks.get(chunkKey);
            if (meshes) {
                meshes.forEach(mesh => {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                });
                chunks.delete(chunkKey);
                
                const startX = cx * chunkSize;
                const startZ = cz * chunkSize;
                for (let x = startX; x < startX + chunkSize; x++) {
                    for (let z = startZ; z < startZ + chunkSize; z++) {
                        for (let y = 0; y < worldHeight; y++) {
                            world.delete(getBlockKey(x, y, z));
                        }
                    }
                }
            }
        }

        function rebuildChunk(cx, cz) {
            const chunkKey = getChunkKey(cx, cz);
            const meshes = chunks.get(chunkKey);
            if (meshes) {
                meshes.forEach(mesh => {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                });
            }
            
            const startX = cx * chunkSize;
            const startZ = cz * chunkSize;
            const blocks = [];
            
            // Collect all blocks in chunk from world data
            for (let x = startX; x < startX + chunkSize; x++) {
                for (let z = startZ; z < startZ + chunkSize; z++) {
                    for (let y = 0; y < worldHeight; y++) {
                        const key = getBlockKey(x, y, z);
                        const blockType = world.get(key);
                        if (blockType) {
                            blocks.push({ x, y, z, type: blockType });
                        }
                    }
                }
            }
            
            // Create new merged meshes
            const newMeshes = createMergedChunkMesh(blocks, cx, cz);
            chunks.set(chunkKey, newMeshes);
            newMeshes.forEach(mesh => scene.add(mesh));
        }

        function updateChunks() {
            const playerChunkX = Math.floor(player.position.x / chunkSize);
            const playerChunkZ = Math.floor(player.position.z / chunkSize);
            
            for (let cx = playerChunkX - renderDistance; cx <= playerChunkX + renderDistance; cx++) {
                for (let cz = playerChunkZ - renderDistance; cz <= playerChunkZ + renderDistance; cz++) {
                    createChunk(cx, cz);
                }
            }
            
            const toRemove = [];
            for (const [key] of chunks) {
                const [cx, cz] = key.split(',').map(Number);
                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cz - playerChunkZ));
                if (dist > renderDistance + 1) {
                    toRemove.push([cx, cz]);
                }
            }
            toRemove.forEach(([cx, cz]) => removeChunk(cx, cz));
        }

        updateChunks();

        // Find spawn
        for (let y = worldHeight - 1; y >= 0; y--) {
            if (world.has(getBlockKey(0, y, 0))) {
                player.position.y = y + 3;
                camera.position.copy(player.position);
                break;
            }
        }

        // Raycasting - optimized
        const raycaster = new THREE.Raycaster();
        raycaster.far = 6;
        const rayDirection = new THREE.Vector3();
        
        // Target block indicator
        const targetGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
        const targetMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            wireframe: true,
            transparent: true,
            opacity: 0.5
        });
        const targetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
        targetIndicator.visible = false;
        scene.add(targetIndicator);

        function getTargetBlock() {
            camera.getWorldDirection(rayDirection);
            raycaster.set(camera.position, rayDirection);
            
            const allMeshes = [];
            chunks.forEach(meshes => allMeshes.push(...meshes));
            const intersects = raycaster.intersectObjects(allMeshes);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                const face = intersects[0].face;
                
                // Calculate block position being looked at
                const x = Math.floor(point.x - face.normal.x * 0.5);
                const y = Math.floor(point.y - face.normal.y * 0.5);
                const z = Math.floor(point.z - face.normal.z * 0.5);
                
                // Show indicator
                targetIndicator.position.set(x, y, z);
                targetIndicator.visible = true;
                
                return {
                    x, y, z,
                    point: point,
                    face: face
                };
            } else {
                targetIndicator.visible = false;
            }
            return null;
        }

        function breakBlock() {
            const target = getTargetBlock();
            if (target) {
                const key = getBlockKey(target.x, target.y, target.z);
                if (world.has(key)) {
                    world.delete(key);
                    
                    const cx = Math.floor(target.x / chunkSize);
                    const cz = Math.floor(target.z / chunkSize);
                    rebuildChunk(cx, cz);
                }
            }
        }

        function placeBlock() {
            const target = getTargetBlock();
            if (target && target.face) {
                // Place on adjacent block
                const normal = target.face.normal;
                const x = target.x + Math.round(normal.x);
                const y = target.y + Math.round(normal.y);
                const z = target.z + Math.round(normal.z);
                
                const playerDist = Math.sqrt(
                    Math.pow(player.position.x - x, 2) +
                    Math.pow(player.position.y - y, 2) +
                    Math.pow(player.position.z - z, 2)
                );
                
                // Don't place inside player
                if (playerDist > player.radius * 2) {
                    const key = getBlockKey(x, y, z);
                    if (!world.has(key)) {
                        world.set(key, player.selectedBlock);
                        
                        const cx = Math.floor(x / chunkSize);
                        const cz = Math.floor(z / chunkSize);
                        rebuildChunk(cx, cz);
                    }
                }
            }
        }

        function isBlockSolid(x, y, z) {
            return world.has(getBlockKey(Math.floor(x), Math.floor(y), Math.floor(z)));
        }

        function updatePlayer(delta) {
            const speed = 5;
            const jumpPower = 7;
            
            const forward = new THREE.Vector3(
                -Math.sin(player.rotation.y), 0, -Math.cos(player.rotation.y)
            ).normalize();
            
            const right = new THREE.Vector3(
                Math.cos(player.rotation.y), 0, -Math.sin(player.rotation.y)
            ).normalize();
            
            const moveX = (keys['KeyD'] || keys['ArrowRight'] || joystickDelta.x > 0.3 ? 1 : 0) - 
                         (keys['KeyA'] || keys['ArrowLeft'] || joystickDelta.x < -0.3 ? 1 : 0);
            const moveZ = (keys['KeyW'] || keys['ArrowUp'] || joystickDelta.y < -0.3 ? 1 : 0) - 
                         (keys['KeyS'] || keys['ArrowDown'] || joystickDelta.y > 0.3 ? 1 : 0);
            
            if (moveX !== 0 || moveZ !== 0) {
                const move = new THREE.Vector3();
                move.addScaledVector(right, moveX);
                move.addScaledVector(forward, moveZ);
                move.normalize().multiplyScalar(speed * delta);
                
                player.position.x += move.x;
                if (isBlockSolid(player.position.x, player.position.y - 1, player.position.z) ||
                    isBlockSolid(player.position.x, player.position.y - 0.5, player.position.z)) {
                    player.position.x -= move.x;
                }
                
                player.position.z += move.z;
                if (isBlockSolid(player.position.x, player.position.y - 1, player.position.z) ||
                    isBlockSolid(player.position.x, player.position.y - 0.5, player.position.z)) {
                    player.position.z -= move.z;
                }
            }
            
            player.velocity.y -= 25 * delta;
            player.velocity.y = Math.max(player.velocity.y, -50);
            player.position.y += player.velocity.y * delta;
            
            const feetY = player.position.y - player.height;
            const blockBelowY = Math.floor(feetY);
            
            if (isBlockSolid(player.position.x, blockBelowY, player.position.z)) {
                player.position.y = blockBelowY + 1 + player.height;
                player.velocity.y = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }
            
            if ((keys['Space'] || keys['jump']) && player.onGround) {
                player.velocity.y = jumpPower;
                player.onGround = false;
            }
            
            if (player.position.y < -10) {
                player.position.y = 20;
                player.velocity.y = 0;
            }
            
            camera.position.copy(player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.rotation.y;
            camera.rotation.x = player.rotation.x;
        }

        // UI
        const inventory = document.getElementById('inventory');
        Object.keys(BLOCKS).forEach(blockType => {
            const slot = document.createElement('div');
            slot.className = 'inv-slot';
            slot.textContent = BLOCKS[blockType].name[0];
            const color = BLOCKS[blockType].color;
            slot.style.background = `rgba(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255}, 0.5)`;
            slot.onclick = () => {
                player.selectedBlock = blockType;
                document.querySelectorAll('.inv-slot').forEach(s => s.classList.remove('active'));
                slot.classList.add('active');
            };
            if (blockType === 'GRASS') slot.classList.add('active');
            inventory.appendChild(slot);
        });

        // Controls
        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code.startsWith('Digit')) {
                const num = parseInt(e.code.slice(-1)) - 1;
                const blockTypes = Object.keys(BLOCKS);
                if (num >= 0 && num < blockTypes.length) {
                    player.selectedBlock = blockTypes[num];
                    document.querySelectorAll('.inv-slot').forEach((s, i) => {
                        s.classList.toggle('active', i === num);
                    });
                }
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);
        document.addEventListener('mousedown', e => {
            if (e.button === 0) breakBlock();
            if (e.button === 2) placeBlock();
        });
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // Touch controls
        let touchStartX = 0, touchStartY = 0, lastTap = 0;
        
        document.addEventListener('touchstart', e => {
            if (e.target.closest('#joystick') || e.target.closest('.control-btn') || e.target.closest('.inv-slot')) return;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchmove', e => {
            if (e.target.closest('#joystick') || e.target.closest('.control-btn') || e.target.closest('.inv-slot')) return;
            const deltaX = e.touches[0].clientX - touchStartX;
            const deltaY = e.touches[0].clientY - touchStartY;
            
            player.rotation.y -= deltaX * 0.003;
            player.rotation.x -= deltaY * 0.003;
            player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', e => {
            if (e.target.closest('#joystick') || e.target.closest('.control-btn') || e.target.closest('.inv-slot')) return;
            const touch = e.changedTouches[0];
            const deltaX = Math.abs(touch.clientX - touchStartX);
            const deltaY = Math.abs(touch.clientY - touchStartY);
            
            if (deltaX < 10 && deltaY < 10) {
                if (e.timeStamp - lastTap < 300) {
                    placeBlock();
                } else {
                    breakBlock();
                }
                lastTap = e.timeStamp;
            }
        });

        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === renderer.domElement) {
                player.rotation.y -= e.movementX * 0.002;
                player.rotation.x -= e.movementY * 0.002;
                player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            }
        });

        renderer.domElement.addEventListener('click', () => {
            if (!isMobile) renderer.domElement.requestPointerLock();
        });

        // Joystick
        const joystick = document.getElementById('joystick');
        const joystickHandle = document.getElementById('joystick-handle');
        let joystickActive = false;
        
        joystick.addEventListener('touchstart', e => {
            e.preventDefault();
            joystickActive = true;
        });
        
        joystick.addEventListener('touchmove', e => {
            if (!joystickActive) return;
            e.preventDefault();
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const touch = e.touches[0];
            
            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 40;
            
            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }
            
            joystickHandle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            joystickDelta = { x: deltaX / maxDistance, y: deltaY / maxDistance };
        });
        
        joystick.addEventListener('touchend', () => {
            joystickActive = false;
            joystickHandle.style.transform = 'translate(-50%, -50%)';
            joystickDelta = { x: 0, y: 0 };
        });

        document.getElementById('jump-btn').addEventListener('touchstart', e => {
            e.preventDefault();
            keys['jump'] = true;
        });
        
        document.getElementById('jump-btn').addEventListener('touchend', () => {
            keys['jump'] = false;
        });

        // Animation loop
        let lastTime = performance.now();
        let frames = 0;
        let lastFpsUpdate = performance.now();
        let lastChunkUpdate = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            updatePlayer(delta);
            
            // Update target indicator every frame
            getTargetBlock();
            
            if (currentTime - lastChunkUpdate > 1000) {
                updateChunks();
                lastChunkUpdate = currentTime;
            }
            
            document.getElementById('pos').textContent = 
                `${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;
            document.getElementById('chunks').textContent = chunks.size;
            
            frames++;
            if (currentTime - lastFpsUpdate > 1000) {
                document.getElementById('fps').textContent = frames;
                frames = 0;
                lastFpsUpdate = currentTime;
            }
            
            renderer.render(scene, camera);
        }
        
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>