<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>KART BLITZ üèéÔ∏è</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Russo+One&family=Orbitron:wght@400;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0f;
    font-family: 'Orbitron', monospace;
    overflow: hidden;
    color: #fff;
  }

  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  canvas {
    display: block;
    image-rendering: pixelated;
  }

  #hud {
    position: absolute;
    top: 0; left: 0; right: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 16px 24px;
    pointer-events: none;
    z-index: 10;
  }

  .hud-panel {
    background: rgba(0,0,0,0.7);
    border: 2px solid #f7c948;
    border-radius: 8px;
    padding: 8px 16px;
    min-width: 120px;
  }

  .hud-label {
    font-size: 10px;
    color: #f7c948;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .hud-value {
    font-family: 'Russo One', sans-serif;
    font-size: 26px;
    color: #fff;
    line-height: 1.1;
  }

  #lapPanel { text-align: center; }

  /* ---- TITLE OVERLAY ---- */
  #titleOverlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 20;
  }

  #titleOverlay h1 {
    font-family: 'Russo One', sans-serif;
    font-size: clamp(40px, 8vw, 80px);
    color: #f7c948;
    text-shadow: 4px 4px 0 #c0392b, 8px 8px 0 #7f0000;
    letter-spacing: 4px;
    margin-bottom: 8px;
    animation: titleBounce 1s ease infinite alternate;
  }

  #titleOverlay p {
    color: #aaa;
    font-size: 13px;
    letter-spacing: 2px;
    margin-bottom: 40px;
  }

  /* ---- KART SELECT ---- */
  #kartSelectOverlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(160deg, #0d0d1a 0%, #1a0a0a 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 20;
  }

  #ks-title {
    font-family: 'Russo One', sans-serif;
    font-size: clamp(22px, 4vw, 40px);
    color: #f7c948;
    letter-spacing: 4px;
    text-shadow: 3px 3px 0 #c0392b;
    margin-bottom: 32px;
  }

  #ks-body {
    display: flex;
    align-items: center;
    gap: 20px;
  }

  #ks-center {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 260px;
  }

  #kartPreview {
    border: 3px solid #f7c948;
    border-radius: 12px;
    background: #111;
    box-shadow: 0 0 30px rgba(247,201,72,0.2);
    margin-bottom: 14px;
  }

  #ks-kartname {
    font-family: 'Russo One', sans-serif;
    font-size: 22px;
    color: #fff;
    letter-spacing: 3px;
    margin-bottom: 16px;
    text-shadow: 2px 2px 0 #000;
  }

  #ks-stats {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 14px;
  }

  .stat-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .stat-label {
    font-size: 10px;
    color: #f7c948;
    letter-spacing: 1px;
    width: 70px;
    text-align: right;
  }

  .stat-bar-bg {
    flex: 1;
    height: 10px;
    background: #222;
    border-radius: 5px;
    overflow: hidden;
    border: 1px solid #333;
  }

  .stat-bar {
    height: 100%;
    border-radius: 5px;
    transition: width 0.4s cubic-bezier(.4,0,.2,1), background 0.4s;
  }

  #ks-tagline {
    font-size: 11px;
    color: #777;
    letter-spacing: 1px;
    font-style: italic;
    text-align: center;
    min-height: 16px;
  }

  .ks-arrow {
    background: rgba(247,201,72,0.1);
    border: 2px solid #f7c948;
    color: #f7c948;
    font-size: 28px;
    width: 52px;
    height: 52px;
    border-radius: 50%;
    cursor: pointer;
    transition: background 0.15s, transform 0.1s;
    display: flex; align-items: center; justify-content: center;
  }
  .ks-arrow:hover { background: rgba(247,201,72,0.25); transform: scale(1.1); }
  .ks-arrow:active { transform: scale(0.95); }

  #ks-dots {
    display: flex;
    gap: 8px;
    margin-top: 20px;
  }

  .ks-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    background: #444;
    cursor: pointer;
    transition: background 0.2s, transform 0.2s;
  }
  .ks-dot.active { background: #f7c948; transform: scale(1.3); }

  .btn-back {
    background: transparent;
    border: 1px solid #555;
    color: #777;
    padding: 8px 24px;
    font-family: 'Orbitron', monospace;
    font-size: 12px;
    letter-spacing: 2px;
    cursor: pointer;
    border-radius: 4px;
    margin-top: 12px;
    transition: color 0.15s, border-color 0.15s;
  }
  .btn-back:hover { color: #aaa; border-color: #aaa; }

  @keyframes titleBounce {
    from { transform: translateY(0); }
    to { transform: translateY(-8px); }
  }

  .btn {
    background: #f7c948;
    color: #000;
    border: none;
    padding: 16px 48px;
    font-family: 'Russo One', sans-serif;
    font-size: 20px;
    letter-spacing: 3px;
    cursor: pointer;
    border-radius: 4px;
    box-shadow: 4px 4px 0 #c0392b;
    transition: transform 0.1s, box-shadow 0.1s;
    text-transform: uppercase;
  }

  .btn:hover { transform: translate(-2px, -2px); box-shadow: 6px 6px 0 #c0392b; }
  .btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 #c0392b; }

  #controls {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px;
    pointer-events: none;
    opacity: 0.5;
    font-size: 11px;
    letter-spacing: 1px;
    color: #888;
  }

  .key {
    background: #222;
    border: 1px solid #444;
    border-radius: 4px;
    padding: 3px 8px;
    color: #ccc;
  }

  #finishOverlay {
    display: none;
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.88);
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 20;
  }

  #finishOverlay h2 {
    font-family: 'Russo One', sans-serif;
    font-size: clamp(32px, 6vw, 64px);
    color: #f7c948;
    text-shadow: 3px 3px 0 #c0392b;
    margin-bottom: 16px;
  }

  #finishTime {
    font-size: 28px;
    color: #fff;
    margin-bottom: 32px;
  }

  #abilityHud {
    position: absolute;
    bottom: 52px;
    left: 24px;
    display: flex;
    align-items: center;
    gap: 12px;
    background: rgba(0,0,0,0.7);
    border: 2px solid #f7c948;
    border-radius: 10px;
    padding: 10px 16px;
    pointer-events: none;
    z-index: 10;
    min-width: 180px;
  }

  #abilityIcon {
    font-size: 28px;
    line-height: 1;
  }

  #abilityInfo {
    flex: 1;
  }

  #abilityName {
    font-size: 10px;
    letter-spacing: 2px;
    color: #f7c948;
    margin-bottom: 4px;
  }

  #abilityCooldownBar {
    width: 100%;
    height: 6px;
    background: #222;
    border-radius: 3px;
    overflow: hidden;
    margin-bottom: 3px;
  }

  #abilityCooldownFill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.1s linear, background 0.3s;
  }

  #abilityStatus {
    font-size: 9px;
    letter-spacing: 1px;
    color: #888;
  }

  #minimap {
    width: 120px;
    height: 120px;
    border: 2px solid #f7c948;
    border-radius: 4px;
    background: rgba(0,0,0,0.6);
    z-index: 10;
  }
  /* ---- COURSE SELECT ---- */
  #courseSelectOverlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(160deg, #0a0d1a 0%, #0d1a0a 100%);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 20;
  }

  #cs-title {
    font-family: 'Russo One', sans-serif;
    font-size: clamp(22px, 4vw, 40px);
    color: #f7c948;
    letter-spacing: 4px;
    text-shadow: 3px 3px 0 #c0392b;
    margin-bottom: 28px;
  }

  #cs-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 16px;
    max-width: 820px;
    width: 90vw;
  }

  .course-card {
    background: rgba(255,255,255,0.04);
    border: 2px solid #333;
    border-radius: 10px;
    padding: 0;
    cursor: pointer;
    transition: border-color 0.2s, transform 0.15s, box-shadow 0.2s;
    overflow: hidden;
  }

  .course-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  }

  .course-card.selected {
    border-color: #f7c948;
    box-shadow: 0 0 20px rgba(247,201,72,0.3);
  }

  .course-card canvas {
    display: block;
    width: 100%;
    height: 110px;
    image-rendering: pixelated;
  }

  .course-card-info {
    padding: 10px 12px 12px;
  }

  .course-name {
    font-family: 'Russo One', sans-serif;
    font-size: 14px;
    letter-spacing: 2px;
    color: #fff;
    margin-bottom: 3px;
  }

  .course-desc {
    font-size: 10px;
    color: #777;
    letter-spacing: 1px;
  }

  .course-diff {
    display: flex;
    gap: 3px;
    margin-top: 6px;
  }

  .course-diff-pip {
    width: 14px;
    height: 5px;
    border-radius: 2px;
    background: #333;
  }

  .course-diff-pip.filled { background: #f7c948; }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <canvas id="minimap"></canvas>

  <div id="hud">
    <div class="hud-panel">
      <div class="hud-label">Speed</div>
      <div class="hud-value" id="speedDisplay">0</div>
    </div>
    <div class="hud-panel" id="lapPanel">
      <div class="hud-label">Lap</div>
      <div class="hud-value" id="lapDisplay">1 / 3</div>
      <div class="hud-label" style="margin-top:4px">Time</div>
      <div class="hud-value" id="timeDisplay" style="font-size:18px">0:00.00</div>
    </div>
    <div class="hud-panel" style="text-align:right">
      <div class="hud-label">Position</div>
      <div class="hud-value" id="posDisplay">1st</div>
    </div>
  </div>

  <!-- Ability HUD -->
  <div id="abilityHud">
    <div id="abilityIcon"></div>
    <div id="abilityInfo">
      <div id="abilityName"></div>
      <div id="abilityCooldownBar"><div id="abilityCooldownFill"></div></div>
      <div id="abilityStatus"></div>
    </div>
  </div>

  <!-- TITLE SCREEN -->
  <div id="titleOverlay">
    <h1>KART BLITZ</h1>
    <p>3-LAP RACE ¬∑ BEAT THE AI KARTS</p>
    <button class="btn" onclick="showKartSelect()">SELECT KART</button>
  </div>

  <!-- KART SELECT SCREEN -->
  <div id="kartSelectOverlay" style="display:none">
    <div id="ks-title">CHOOSE YOUR KART</div>
    <div id="ks-body">
      <button class="ks-arrow" id="ks-left" onclick="changeKart(-1)">&#9664;</button>
      <div id="ks-center">
        <canvas id="kartPreview" width="220" height="180"></canvas>
        <div id="ks-kartname"></div>
        <div id="ks-stats">
          <div class="stat-row"><span class="stat-label">SPEED</span><div class="stat-bar-bg"><div class="stat-bar" id="stat-speed"></div></div></div>
          <div class="stat-row"><span class="stat-label">ACCEL</span><div class="stat-bar-bg"><div class="stat-bar" id="stat-accel"></div></div></div>
          <div class="stat-row"><span class="stat-label">HANDLING</span><div class="stat-bar-bg"><div class="stat-bar" id="stat-handling"></div></div></div>
          <div class="stat-row"><span class="stat-label">WEIGHT</span><div class="stat-bar-bg"><div class="stat-bar" id="stat-weight"></div></div></div>
        </div>
        <div id="ks-tagline"></div>
      </div>
      <button class="ks-arrow" id="ks-right" onclick="changeKart(1)">&#9654;</button>
    </div>
    <div id="ks-dots"></div>
    <button class="btn" style="margin-top:28px" onclick="showCourseSelect()">NEXT ‚Üí</button>
    <button class="btn-back" onclick="showTitle()">&#8592; BACK</button>
  </div>

  <!-- COURSE SELECT SCREEN -->
  <div id="courseSelectOverlay">
    <div id="cs-title">CHOOSE YOUR COURSE</div>
    <div id="cs-grid" id="cs-grid"></div>
    <div style="display:flex;gap:16px;margin-top:24px">
      <button class="btn" onclick="startGame()">RACE!</button>
      <button class="btn-back" style="margin-top:0;padding:16px 24px" onclick="showKartSelect()">&#8592; BACK</button>
    </div>
  </div>

  <div id="finishOverlay">
    <h2 id="finishTitle">RACE COMPLETE!</h2>
    <div id="finishTime"></div>
    <button class="btn" onclick="restartGame()">RACE AGAIN</button>
    <button class="btn-back" style="margin-top:12px" onclick="showCourseSelect()">&#8592; CHANGE COURSE</button>
    <button class="btn-back" style="margin-top:8px" onclick="showKartSelect()">&#8592; CHANGE KART</button>
  </div>

  <div id="controls">
    <span class="key">‚Üë W</span> Accelerate &nbsp;
    <span class="key">‚Üì S</span> Brake &nbsp;
    <span class="key">‚Üê ‚Üí</span> Steer &nbsp;
    <span class="key">SPACE</span> Drift &nbsp;
    <span class="key">E / SHIFT</span> Ability
  </div>
</div>

<script>
// ===================== KART ROSTER =====================
const KART_ROSTER = [
  {
    name: 'BLAZE',
    color: '#e74c3c', bodyColor: '#e74c3c', accentColor: '#ff8c00',
    speed: 95, accel: 55, handling: 60, weight: 65,
    tagline: '"Pure speed, no apologies"',
    maxSpeed: 5, accelRate: 0.32, turnRate: 0.040, friction: 0.945,
    ability: { name: 'AFTERBURNER', icon: 'üî•', desc: 'Massive speed burst for 3s', cooldown: 8000 },
  },
  {
    name: 'TURBO',
    color: '#3498db', bodyColor: '#3498db', accentColor: '#00eaff',
    speed: 70, accel: 90, handling: 70, weight: 50,
    tagline: '"Zero to hero in 0.2 seconds"',
    maxSpeed: 4.5, accelRate: 0.48, turnRate: 0.044, friction: 0.93,
    ability: { name: 'ROCKET START', icon: 'üöÄ', desc: 'Instant full speed lunge', cooldown: 6000 },
  },
  {
    name: 'VIPER',
    color: '#2ecc71', bodyColor: '#2ecc71', accentColor: '#fff',
    speed: 75, accel: 70, handling: 95, weight: 45,
    tagline: '"Corners like it\'s on rails"',
    maxSpeed: 4.8, accelRate: 0.38, turnRate: 0.056, friction: 0.935,
    ability: { name: 'PHASE SHIFT', icon: 'üëª', desc: 'Pass through walls for 2s', cooldown: 10000 },
  },
  {
    name: 'CRUSHER',
    color: '#e67e22', bodyColor: '#e67e22', accentColor: '#ffd700',
    speed: 65, accel: 60, handling: 50, weight: 95,
    tagline: '"Built like a tank, drives like one too"',
    maxSpeed: 4.2, accelRate: 0.34, turnRate: 0.034, friction: 0.955,
    ability: { name: 'ARMOUR SHELL', icon: 'üõ°Ô∏è', desc: 'No speed loss from walls for 4s', cooldown: 7000 },
  },
  {
    name: 'PHANTOM',
    color: '#9b59b6', bodyColor: '#9b59b6', accentColor: '#e056fd',
    speed: 80, accel: 75, handling: 80, weight: 55,
    tagline: '"The all-rounder with style"',
    maxSpeed: 5.0, accelRate: 0.40, turnRate: 0.048, friction: 0.938,
    ability: { name: 'GHOST DASH', icon: '‚ö°', desc: 'Teleport forward on the track', cooldown: 9000 },
  },
];

let selectedKartIdx = 0;
let selectedCourseIdx = 0;
let previewAngle = 0;

// ===================== COURSE DEFINITIONS =====================
const COURSES = [
  {
    name: 'GRAND OVAL',
    desc: 'Classic sweeping circuit',
    difficulty: 1,
    skyTop: '#0a0520', skyBot: '#1a1060',
    groundColor: '#1a3a0a',
    wallColor: '#888',
    pts: [
      [600,150],[400,180],[200,190],[0,190],[-200,190],[-400,180],[-600,150],
      [-750,80],[-860,-50],[-920,-200],[-920,-380],
      [-880,-540],[-780,-660],[-640,-740],
      [-440,-790],[-220,-810],[0,-810],[220,-810],[440,-790],
      [640,-740],[780,-660],[880,-540],
      [920,-380],[920,-200],[860,-50],[750,80],[680,120],
    ],
  },
  {
    name: 'DESERT DUNES',
    desc: 'Winding sand dunes with tight S-bends',
    difficulty: 2,
    skyTop: '#1a0a00', skyBot: '#4a2800',
    groundColor: '#5a3a10',
    wallColor: '#c8a060',
    pts: [
      [700,0],[600,-80],[400,-200],[150,-280],
      [-50,-240],[-200,-120],[-280,50],[-200,200],
      [-50,320],[150,380],[350,320],[500,180],
      [600,50],[700,0],
    ],
  },
  {
    name: 'NEON CITY',
    desc: 'Urban street circuit through neon-lit blocks',
    difficulty: 3,
    skyTop: '#000010', skyBot: '#0a003a',
    groundColor: '#111122',
    wallColor: '#334',
    pts: [
      [800,100],[800,-100],[800,-400],
      [600,-600],[200,-600],[-200,-600],
      [-600,-600],[-800,-400],[-800,-100],[-800,100],
      [-800,300],[-600,500],[-200,500],
      [200,500],[600,500],[800,300],[800,100],
    ],
  },
  {
    name: 'ALPINE PASS',
    desc: 'Treacherous mountain hairpins',
    difficulty: 4,
    skyTop: '#050510', skyBot: '#102030',
    groundColor: '#e8eef0',
    wallColor: '#bcd',
    pts: [
      [500,200],[300,100],[100,0],[-100,-50],
      [-300,-20],[-500,80],[-650,250],[-680,450],
      [-580,620],[-380,720],[-150,730],[100,670],
      [350,550],[550,380],[600,200],[500,200],
    ],
  },
  {
    name: 'VOLCANO RUN',
    desc: 'Race around an erupting volcano',
    difficulty: 5,
    skyTop: '#1a0000', skyBot: '#3a0500',
    groundColor: '#2a1008',
    wallColor: '#554',
    pts: [
      [900,50],[850,-200],[700,-450],[500,-650],
      [200,-800],[-100,-820],[-400,-750],[-650,-580],
      [-800,-320],[-820,-50],[-720,220],[-520,430],
      [-250,580],[50,620],[350,560],[600,400],
      [780,200],[900,50],
    ],
  },
];

function showCourseSelect() {
  document.getElementById('kartSelectOverlay').style.display = 'none';
  document.getElementById('finishOverlay').style.display = 'none';
  document.getElementById('courseSelectOverlay').style.display = 'flex';
  renderCourseSelect();
}

function renderCourseSelect() {
  const grid = document.getElementById('cs-grid');
  grid.innerHTML = '';
  COURSES.forEach((c, i) => {
    const card = document.createElement('div');
    card.className = 'course-card' + (i === selectedCourseIdx ? ' selected' : '');
    card.onclick = () => { selectedCourseIdx = i; renderCourseSelect(); };

    // Mini preview canvas
    const cv = document.createElement('canvas');
    cv.width = 240; cv.height = 110;
    card.appendChild(cv);
    drawCoursePreview(cv, c, i === selectedCourseIdx);

    const info = document.createElement('div');
    info.className = 'course-card-info';
    info.innerHTML = `
      <div class="course-name">${c.name}</div>
      <div class="course-desc">${c.desc}</div>
      <div class="course-diff">
        ${[1,2,3,4,5].map(d=>`<div class="course-diff-pip${d<=c.difficulty?' filled':''}"></div>`).join('')}
        <span style="font-size:9px;color:#777;margin-left:4px;letter-spacing:1px">DIFFICULTY</span>
      </div>`;
    card.appendChild(info);
    grid.appendChild(card);
  });
}

function drawCoursePreview(cv, course, selected) {
  const pctx = cv.getContext('2d');
  const cw = cv.width, ch = cv.height;
  pctx.clearRect(0, 0, cw, ch);

  // Background
  const bg = pctx.createLinearGradient(0, 0, 0, ch);
  bg.addColorStop(0, course.skyTop);
  bg.addColorStop(1, course.skyBot);
  pctx.fillStyle = bg;
  pctx.fillRect(0, 0, cw, ch);

  // Find bounds of course
  const xs = course.pts.map(p=>p[0]), ys = course.pts.map(p=>p[1]);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const scaleX = (cw - 20) / (maxX - minX);
  const scaleY = (ch - 20) / (maxY - minY);
  const sc = Math.min(scaleX, scaleY) * 0.85;
  const ox = cw/2 - (minX + maxX)/2 * sc;
  const oy = ch/2 - (minY + maxY)/2 * sc;

  const tx = x => x * sc + ox;
  const ty = y => y * sc + oy;

  // Draw track width
  pctx.strokeStyle = '#555';
  pctx.lineWidth = 8;
  pctx.lineJoin = 'round';
  pctx.beginPath();
  course.pts.forEach(([x,y],i) => i===0 ? pctx.moveTo(tx(x),ty(y)) : pctx.lineTo(tx(x),ty(y)));
  pctx.closePath();
  pctx.stroke();

  // Center line
  pctx.strokeStyle = course.wallColor;
  pctx.lineWidth = 3;
  pctx.beginPath();
  course.pts.forEach(([x,y],i) => i===0 ? pctx.moveTo(tx(x),ty(y)) : pctx.lineTo(tx(x),ty(y)));
  pctx.closePath();
  pctx.stroke();

  // Start dot
  pctx.fillStyle = selected ? '#f7c948' : '#fff';
  pctx.shadowColor = selected ? '#f7c948' : 'transparent';
  pctx.shadowBlur = selected ? 8 : 0;
  pctx.beginPath();
  pctx.arc(tx(course.pts[0][0]), ty(course.pts[0][1]), 5, 0, Math.PI*2);
  pctx.fill();
  pctx.shadowBlur = 0;
}

function showTitle() {
  document.getElementById('titleOverlay').style.display = 'flex';
  document.getElementById('kartSelectOverlay').style.display = 'none';
  document.getElementById('courseSelectOverlay').style.display = 'none';
}

function showKartSelect() {
  document.getElementById('titleOverlay').style.display = 'none';
  document.getElementById('kartSelectOverlay').style.display = 'flex';
  document.getElementById('courseSelectOverlay').style.display = 'none';
  document.getElementById('finishOverlay').style.display = 'none';
  renderKartSelect();
  requestAnimationFrame(animatePreview);
}

function changeKart(dir) {
  selectedKartIdx = (selectedKartIdx + dir + KART_ROSTER.length) % KART_ROSTER.length;
  renderKartSelect();
}

function renderKartSelect() {
  const k = KART_ROSTER[selectedKartIdx];
  document.getElementById('ks-kartname').textContent = k.name;
  document.getElementById('ks-tagline').textContent = k.tagline;
  // Show ability
  let abilEl = document.getElementById('ks-ability');
  if (!abilEl) {
    abilEl = document.createElement('div');
    abilEl.id = 'ks-ability';
    abilEl.style.cssText = 'margin-top:10px;padding:8px 14px;background:rgba(255,255,255,0.07);border:1px solid rgba(255,255,255,0.15);border-radius:6px;text-align:center;font-size:11px;letter-spacing:1px;color:#ddd;line-height:1.6';
    document.getElementById('ks-center').appendChild(abilEl);
  }
  abilEl.innerHTML = `<span style="font-size:18px">${k.ability.icon}</span> <span style="color:${k.accentColor};font-weight:bold;letter-spacing:2px">${k.ability.name}</span><br><span style="color:#888">${k.ability.desc}</span>`;

  const stats = { speed: k.speed, accel: k.accel, handling: k.handling, weight: k.weight };
  const colors = { speed: '#e74c3c', accel: '#f7c948', handling: '#2ecc71', weight: '#3498db' };
  for (const [key, val] of Object.entries(stats)) {
    const bar = document.getElementById('stat-' + key);
    bar.style.width = val + '%';
    bar.style.background = colors[key];
    bar.style.boxShadow = `0 0 8px ${colors[key]}88`;
  }

  // Dots
  const dotsEl = document.getElementById('ks-dots');
  dotsEl.innerHTML = '';
  KART_ROSTER.forEach((_, i) => {
    const d = document.createElement('div');
    d.className = 'ks-dot' + (i === selectedKartIdx ? ' active' : '');
    d.onclick = () => { selectedKartIdx = i; renderKartSelect(); };
    dotsEl.appendChild(d);
  });

  drawKartPreview();
}

function drawKartPreview() {
  const pc = document.getElementById('kartPreview');
  const pctx = pc.getContext('2d');
  const k = KART_ROSTER[selectedKartIdx];
  pctx.clearRect(0, 0, 220, 180);

  // Background grid
  pctx.fillStyle = '#0d0d1a';
  pctx.fillRect(0, 0, 220, 180);
  pctx.strokeStyle = 'rgba(247,201,72,0.07)';
  pctx.lineWidth = 1;
  for (let x = 0; x < 220; x += 22) { pctx.beginPath(); pctx.moveTo(x,0); pctx.lineTo(x,180); pctx.stroke(); }
  for (let y = 0; y < 180; y += 22) { pctx.beginPath(); pctx.moveTo(0,y); pctx.lineTo(220,y); pctx.stroke(); }

  // Glow circle behind kart
  const grd = pctx.createRadialGradient(110, 90, 10, 110, 90, 70);
  grd.addColorStop(0, k.color + '44');
  grd.addColorStop(1, 'transparent');
  pctx.fillStyle = grd;
  pctx.fillRect(0, 0, 220, 180);

  // Draw the kart large, centered, with previewAngle
  pctx.save();
  pctx.translate(110, 90);
  pctx.rotate(previewAngle + Math.PI / 2);
  const scale = 2.6;
  pctx.scale(scale, scale);

  // Shadow
  pctx.fillStyle = 'rgba(0,0,0,0.4)';
  pctx.beginPath(); pctx.ellipse(3, 4, 18, 10, 0, 0, Math.PI*2); pctx.fill();

  // Body
  pctx.fillStyle = k.bodyColor;
  pctx.beginPath(); pctx.roundRect(-14, -20, 28, 36, 5); pctx.fill();

  // Accent stripe
  pctx.fillStyle = k.accentColor;
  pctx.fillRect(-6, -20, 12, 6);
  pctx.fillRect(-6, 8, 12, 6);

  // Cockpit
  pctx.fillStyle = k.accentColor;
  pctx.beginPath(); pctx.ellipse(0, -4, 8, 10, 0, 0, Math.PI*2); pctx.fill();

  // Cockpit glass
  pctx.fillStyle = 'rgba(255,255,255,0.3)';
  pctx.beginPath(); pctx.ellipse(0, -6, 5, 7, 0, 0, Math.PI*2); pctx.fill();

  // Wheels
  pctx.fillStyle = '#111';
  [[-14,-14],[14,-14],[-14,12],[14,12]].forEach(([wx,wy]) => {
    pctx.beginPath(); pctx.roundRect(wx-5, wy-6, 10, 12, 2); pctx.fill();
    // Hubcap
    pctx.fillStyle = '#444';
    pctx.beginPath(); pctx.arc(wx, wy, 3, 0, Math.PI*2); pctx.fill();
    pctx.fillStyle = '#111';
  });

  pctx.restore();

  // Kart name label at bottom
  pctx.fillStyle = k.accentColor;
  pctx.font = 'bold 13px Orbitron, monospace';
  pctx.textAlign = 'center';
  pctx.fillText(k.name, 110, 168);
}

function animatePreview(ts) {
  previewAngle = ts * 0.001;
  drawKartPreview();
  if (document.getElementById('kartSelectOverlay').style.display !== 'none') {
    requestAnimationFrame(animatePreview);
  }
}

// ===================== GAME ENGINE =====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap');
const mctx = minimapCanvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ===================== TRACK =====================
// Track defined as centerline waypoints + width
const TRACK_WIDTH = 320;
const trackPoints = [];
function buildTrack() {
  trackPoints.length = 0;
  const course = COURSES[selectedCourseIdx] || COURSES[0];
  for (const [x, y] of course.pts) trackPoints.push({ x, y });
}
buildTrack();

function getTrackSegment(idx) {
  const a = trackPoints[idx % trackPoints.length];
  const b = trackPoints[(idx + 1) % trackPoints.length];
  return { a, b };
}

function closestPointOnSegment(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const len2 = dx * dx + dy * dy;
  if (len2 === 0) return { x: ax, y: ay, t: 0 };
  let t = ((px - ax) * dx + (py - ay) * dy) / len2;
  t = Math.max(0, Math.min(1, t));
  return { x: ax + t * dx, y: ay + t * dy, t };
}

function getClosestTrack(px, py) {
  let minDist = Infinity, bestSeg = 0, bestT = 0, bestX = 0, bestY = 0;
  for (let i = 0; i < trackPoints.length; i++) {
    const { a, b } = getTrackSegment(i);
    const cp = closestPointOnSegment(px, py, a.x, a.y, b.x, b.y);
    const d = Math.hypot(px - cp.x, py - cp.y);
    if (d < minDist) { minDist = d; bestSeg = i; bestT = cp.t; bestX = cp.x; bestY = cp.y; }
  }
  return { dist: minDist, seg: bestSeg, t: bestT, cx: bestX, cy: bestY };
}

function trackProgress(seg, t) {
  return (seg + t) / trackPoints.length;
}

// ===================== WALL COLLISION =====================
const WALL_MARGIN = TRACK_WIDTH / 2 - 12; // kart radius buffer

function applyWallCollision(k) {
  const { dist, cx, cy } = getClosestTrack(k.x, k.y);
  if (dist > WALL_MARGIN) {
    // Push kart back inside the track
    const overlap = dist - WALL_MARGIN;
    const nx = (k.x - cx) / dist;
    const ny = (k.y - cy) / dist;
    k.x -= nx * overlap;
    k.y -= ny * overlap;

    // Reflect the kart's travel direction off the wall normal
    // Current velocity vector based on angle + speed
    let vx = Math.cos(k.angle) * k.speed;
    let vy = Math.sin(k.angle) * k.speed;

    // dot product of velocity with wall normal
    const dot = vx * nx + vy * ny;

    // Only absorb wall impact - no bounce
    if (dot > 0) {
      vx -= dot * nx;
      vy -= dot * ny;
      k.speed = Math.hypot(vx, vy);
      k.angle = Math.atan2(vy, vx);
    }
  }
}

// ===================== KART =====================
const KART_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#e67e22', '#9b59b6'];
const KART_NAMES = ['YOU', 'CPU1', 'CPU2', 'CPU3', 'CPU4'];

function createKart(idx, isPlayer) {
  const sp = trackPoints[1];
  const offset = (idx - 2) * 60;
  const rosterKart = isPlayer ? KART_ROSTER[selectedKartIdx] : KART_ROSTER[idx % KART_ROSTER.length];
  return {
    x: sp.x + offset, y: sp.y + 80 * idx,
    angle: Math.atan2(trackPoints[2].y - trackPoints[1].y, trackPoints[2].x - trackPoints[1].x),
    speed: 0, vx: 0, vy: 0,
    color: rosterKart.color,
    accentColor: rosterKart.accentColor,
    name: isPlayer ? 'YOU' : KART_NAMES[idx],
    isPlayer,
    lap: 1, lastSeg: 0, lastProgress: 0,
    drifting: false, driftAngle: 0,
    finished: false, finishTime: 0,
    cpSeg: 1, cpT: 0,
    // stats
    maxSpeed: isPlayer ? rosterKart.maxSpeed : 3.8 + Math.random() * 0.8,
    accelRate: isPlayer ? rosterKart.accelRate : 0.30 + Math.random() * 0.08,
    turnRate: isPlayer ? rosterKart.turnRate : 0.038 + Math.random() * 0.01,
    friction: isPlayer ? rosterKart.friction : 0.935 + Math.random() * 0.01,
    // ability
    abilityName: rosterKart.ability.name,
    abilityCooldown: rosterKart.ability.cooldown,
    abilityLastUsed: -99999,
    abilityActive: false,
    abilityTimer: 0,
  };
}

// ===================== GAME STATE =====================
let karts = [];
let player;
let keys = {};
let raceStarted = false;
let raceTime = 0;
let countdown = 0;
let countdownTimer = 0;
let animId;

const TOTAL_LAPS = 3;
const MAX_SPEED = 14;
const ACCEL = 0.35;
const BRAKE = 0.5;
const FRICTION = 0.94;
const TURN_SPEED = 0.045;
const OFF_TRACK_FACTOR = 0.55;

function startGame() {
  document.getElementById('titleOverlay').style.display = 'none';
  document.getElementById('kartSelectOverlay').style.display = 'none';
  document.getElementById('courseSelectOverlay').style.display = 'none';
  document.getElementById('finishOverlay').style.display = 'none';
  buildTrack();
  buildEdges();
  karts = [];
  for (let i = 0; i < 5; i++) karts.push(createKart(i, i === 0));
  player = karts[0];
  raceStarted = false;
  raceTime = 0;
  countdown = 3;
  countdownTimer = 0;
  if (animId) cancelAnimationFrame(animId);
  lastTime = 0;
  loop();
}

function restartGame() { startGame(); }

// ===================== INPUT =====================
document.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault(); });
document.addEventListener('keyup', e => { keys[e.code] = false; });

// ===================== CPU AI =====================
function updateCPU(k, dt) {
  if (k.finished) return;
  const { seg, t, cx, cy } = getClosestTrack(k.x, k.y);
  // Target a point ahead on track
  const targetIdx = (seg + 3) % trackPoints.length;
  const tp = trackPoints[targetIdx];
  const targetAngle = Math.atan2(tp.y - k.y, tp.x - k.x);
  let da = targetAngle - k.angle;
  while (da > Math.PI) da -= Math.PI * 2;
  while (da < -Math.PI) da += Math.PI * 2;
  k.angle += Math.sign(da) * Math.min(Math.abs(da), TURN_SPEED * 1.2);

  const distFromCenter = Math.hypot(k.x - cx, k.y - cy);
  const onTrack = distFromCenter < TRACK_WIDTH / 2;
  const speedFactor = onTrack ? 1 : OFF_TRACK_FACTOR;
  const topSpeed = (k.maxSpeed - 2) * speedFactor;

  if (k.speed < topSpeed) k.speed += k.accelRate * 0.8;
  k.speed *= k.friction;

  k.x += Math.cos(k.angle) * k.speed;
  k.y += Math.sin(k.angle) * k.speed;
  applyWallCollision(k);
}

// ===================== ABILITY SYSTEM =====================
function activateAbility(k) {
  const now = raceTime;
  if (k.abilityActive) return;
  if (now - k.abilityLastUsed < k.abilityCooldown) return;

  k.abilityLastUsed = now;
  k.abilityActive = true;

  switch (k.abilityName) {
    case 'AFTERBURNER':
      k.abilityTimer = 3000;
      break;
    case 'ROCKET START':
      // Instant lunge forward
      k.speed = k.maxSpeed * 1.5;
      k.abilityActive = false; // instant
      k.abilityTimer = 0;
      spawnParticles(k.x, k.y, k.accentColor, 20);
      break;
    case 'PHASE SHIFT':
      k.abilityTimer = 2000;
      break;
    case 'ARMOUR SHELL':
      k.abilityTimer = 4000;
      break;
    case 'GHOST DASH': {
      // Teleport forward ~600 units on the track centerline
      const { seg } = getClosestTrack(k.x, k.y);
      const fwdSeg = (seg + 5) % trackPoints.length;
      spawnParticles(k.x, k.y, k.accentColor, 16);
      k.x = trackPoints[fwdSeg].x;
      k.y = trackPoints[fwdSeg].y;
      spawnParticles(k.x, k.y, k.accentColor, 16);
      k.abilityActive = false;
      k.abilityTimer = 0;
      break;
    }
  }
}

function updateAbility(k, dtMs) {
  if (!k.abilityActive) return;
  k.abilityTimer -= dtMs;
  if (k.abilityTimer <= 0) {
    k.abilityActive = false;
    k.abilityTimer = 0;
  }
}

// ===================== PARTICLES =====================
const particles = [];
function spawnParticles(x, y, color, count = 10) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 6;
    particles.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, life: 1, color, size: 3 + Math.random()*5 });
  }
}

function updateParticles(dtMs) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.92; p.vy *= 0.92;
    p.life -= dtMs / 600;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = p.life * 0.9;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ===================== PLAYER =====================
function updatePlayer(dt) {
  if (player.finished) return;
  const dtMs = dt * 16.67;
  updateAbility(player, dtMs);

  const { seg, t, cx, cy } = getClosestTrack(player.x, player.y);
  const distFromCenter = Math.hypot(player.x - cx, player.y - cy);
  const onTrack = distFromCenter < TRACK_WIDTH / 2;
  const speedFactor = onTrack ? 1 : OFF_TRACK_FACTOR;

  const accel = keys['ArrowUp'] || keys['KeyW'];
  const braking = keys['ArrowDown'] || keys['KeyS'];
  const left = keys['ArrowLeft'] || keys['KeyA'];
  const right = keys['ArrowRight'] || keys['KeyD'];
  player.drifting = keys['Space'];

  if ((keys['KeyE'] || keys['ShiftLeft']) && !player._abilityKeyHeld) {
    player._abilityKeyHeld = true;
    activateAbility(player);
  }
  if (!keys['KeyE'] && !keys['ShiftLeft']) player._abilityKeyHeld = false;

  // Apply ability speed modifiers
  let topSpeed = player.maxSpeed * speedFactor;
  let accelRate = player.accelRate;
  if (player.abilityActive && player.abilityName === 'AFTERBURNER') {
    topSpeed *= 1.6;
    accelRate *= 2;
    if (Math.random() < 0.4) spawnParticles(
      player.x - Math.cos(player.angle) * 20,
      player.y - Math.sin(player.angle) * 20,
      '#ff6600', 2);
  }

  if (accel) player.speed = Math.min(player.speed + accelRate, topSpeed);
  if (braking) player.speed = Math.max(player.speed - BRAKE, -4);
  if (!accel && !braking) player.speed *= player.friction;

  const turnMult = player.drifting ? 1.6 : 1;
  if (left) player.angle -= player.turnRate * turnMult;
  if (right) player.angle += player.turnRate * turnMult;

  player.x += Math.cos(player.angle) * player.speed;
  player.y += Math.sin(player.angle) * player.speed;

  // Phase Shift: skip wall collision
  if (!(player.abilityActive && player.abilityName === 'PHASE SHIFT')) {
    applyWallCollision(player);
  }
}

// ===================== LAP TRACKING =====================
// Start/finish is near trackPoints[0]
function updateLaps(k) {
  if (k.finished) return;
  const { seg, t } = getClosestTrack(k.x, k.y);
  const prog = trackProgress(seg, t);

  // Crossed finish line: progress goes from ~0.95+ to ~0.05
  const lastProg = k.lastProgress;
  if (lastProg > 0.9 && prog < 0.15) {
    k.lap++;
    if (k.lap > TOTAL_LAPS) {
      k.finished = true;
      k.finishTime = raceTime;
      if (k.isPlayer) showFinish();
    }
  }
  k.lastProgress = prog;
  k.cpSeg = seg; k.cpT = t;
}

function getRacePosition() {
  const sorted = [...karts].sort((a, b) => {
    if (a.lap !== b.lap) return b.lap - a.lap;
    return trackProgress(b.cpSeg, b.cpT) - trackProgress(a.cpSeg, a.cpT);
  });
  return sorted.findIndex(k => k.isPlayer) + 1;
}

const ordinals = ['1st', '2nd', '3rd', '4th', '5th'];

function showFinish() {
  const overlay = document.getElementById('finishOverlay');
  const pos = getRacePosition();
  document.getElementById('finishTitle').textContent =
    pos === 1 ? 'üèÜ RACE WIN! üèÜ' : `FINISHED ${ordinals[pos - 1]}`;
  document.getElementById('finishTime').textContent = formatTime(player.finishTime);
  overlay.style.display = 'flex';
}

// ===================== RENDER =====================
function formatTime(ms) {
  const m = Math.floor(ms / 60000);
  const s = Math.floor((ms % 60000) / 1000);
  const cs = Math.floor((ms % 1000) / 10);
  return `${m}:${s.toString().padStart(2,'0')}.${cs.toString().padStart(2,'0')}`;
}

// Pre-build edge arrays for rendering
let outerEdge = [], innerEdge = [];
function buildEdges() {
  outerEdge = []; innerEdge = [];
  for (let i = 0; i < trackPoints.length; i++) {
    const a = trackPoints[i];
    const b = trackPoints[(i + 1) % trackPoints.length];
    const nx = -(b.y - a.y), ny = (b.x - a.x);
    const len = Math.hypot(nx, ny);
    const ux = nx / len, uy = ny / len;
    outerEdge.push({ x: a.x + ux * TRACK_WIDTH / 2, y: a.y + uy * TRACK_WIDTH / 2 });
    innerEdge.push({ x: a.x - ux * TRACK_WIDTH / 2, y: a.y - uy * TRACK_WIDTH / 2 });
  }
}

// ---- First-person raycaster ----
const FOV = Math.PI / 2.2;        // field of view
const NUM_RAYS = 480;              // one per column roughly
const MAX_DIST = 2200;
const WALL_HEIGHT_SCALE = 18000;
const CAM_HEIGHT = 0.52;           // 0=floor, 1=ceiling

function castRay(ox, oy, angle) {
  const dx = Math.cos(angle), dy = Math.sin(angle);
  // Walk along ray and find where it exits the track
  let step = 8;
  for (let d = step; d < MAX_DIST; d += step) {
    const rx = ox + dx * d, ry = oy + dy * d;
    const { dist: td } = getClosestTrack(rx, ry);
    if (td > TRACK_WIDTH / 2 - 4) return { dist: d, onOuter: true };
    step = Math.max(4, (TRACK_WIDTH / 2 - td) * 0.5);
  }
  return { dist: MAX_DIST, onOuter: false };
}

function drawFirstPerson() {
  const px = player.x, py = player.y, pa = player.angle;
  const horizon = H * CAM_HEIGHT;
  const course = COURSES[selectedCourseIdx] || COURSES[0];

  // Sky gradient
  const sky = ctx.createLinearGradient(0, 0, 0, horizon);
  sky.addColorStop(0, course.skyTop);
  sky.addColorStop(1, course.skyBot);
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, W, horizon);

  // Draw course-specific background scenery
  drawSkyBackground(pa, horizon, course);

function drawSkyBackground(pa, horizon, course) {
  // Pan the background based on player angle (parallax)
  const panX = (-pa / (Math.PI * 2)) * W * 2;
  const wrap = x => ((x % (W * 2)) + W * 2) % (W * 2) - W * 0.5;

  ctx.save();
  const idx = COURSES.indexOf(course);

  if (idx === 0) {
    // ‚îÄ‚îÄ GRAND OVAL: rolling green hills + white clouds ‚îÄ‚îÄ
    // Distant hills
    for (let layer = 0; layer < 3; layer++) {
      const px2 = panX * (0.1 + layer * 0.08);
      ctx.fillStyle = `hsl(${120 + layer*10}, ${40-layer*8}%, ${18+layer*8}%)`;
      ctx.beginPath();
      for (let i = 0; i <= 24; i++) {
        const x = (i / 24) * W * 2.2 - W * 0.1 + (px2 * (0.3 + layer*0.1)) % (W*2.2);
        const y = horizon - 20 - layer * 22 + Math.sin(i * 0.7 + layer * 2.3) * (25 + layer * 18);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.lineTo(W * 2.2, horizon); ctx.lineTo(-W * 0.1, horizon); ctx.closePath(); ctx.fill();
    }
    // White clouds
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    const clouds = [[0.1,0.25,60,22],[0.3,0.15,90,28],[0.55,0.3,75,20],[0.75,0.18,110,32],[0.9,0.28,50,18]];
    for (const [fx, fy, cw, ch] of clouds) {
      const cx2 = wrap(fx * W * 2 + panX * 0.06) % W;
      const cy2 = horizon * fy;
      ctx.beginPath(); ctx.ellipse(cx2, cy2, cw, ch, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(cx2+cw*0.5, cy2+4, cw*0.7, ch*0.7, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(cx2-cw*0.4, cy2+6, cw*0.6, ch*0.6, 0, 0, Math.PI*2); ctx.fill();
    }

  } else if (idx === 1) {
    // ‚îÄ‚îÄ DESERT DUNES: sand dunes + hot sun + heat haze ‚îÄ‚îÄ
    // Sun
    const sunX = wrap(W * 0.7 + panX * 0.02);
    const sunGrad = ctx.createRadialGradient(sunX, horizon * 0.3, 0, sunX, horizon * 0.3, 80);
    sunGrad.addColorStop(0, '#fff8e0'); sunGrad.addColorStop(0.2, '#ffcc44'); sunGrad.addColorStop(1, 'rgba(255,140,0,0)');
    ctx.fillStyle = sunGrad; ctx.fillRect(sunX-80, 0, 160, horizon);
    // Dune layers
    for (let layer = 0; layer < 4; layer++) {
      const shift = panX * (0.12 + layer * 0.07);
      const duneL = [38,32,26,20][layer] || 20;
      ctx.fillStyle = `hsl(35, ${55-layer*8}%, ${duneL}%)`;
      ctx.beginPath();
      ctx.moveTo(-W*0.1, horizon);
      for (let i = 0; i <= 20; i++) {
        const x = (i/20)*W*1.2 - W*0.1 + shift % (W*1.2);
        const y = horizon - (layer+1)*16 + Math.sin(i*0.9 + layer*1.7)*( 18 + layer*22);
        i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
      }
      ctx.lineTo(W*1.2, horizon); ctx.closePath(); ctx.fill();
    }
    // Heat shimmer lines
    ctx.strokeStyle = 'rgba(255,180,50,0.08)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 6; i++) {
      const y = horizon * (0.7 + i * 0.05);
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }

  } else if (idx === 2) {
    // ‚îÄ‚îÄ NEON CITY: cyberpunk skyline ‚îÄ‚îÄ
    // City buildings silhouette (back layer)
    ctx.fillStyle = '#080818';
    const buildingSeeds = [0.05,80,0.12,110,0.19,70,0.26,130,0.33,90,0.4,100,0.47,120,0.54,85,0.61,140,0.68,75,0.75,115,0.82,95,0.89,105,0.96,80];
    for (let i = 0; i < buildingSeeds.length; i+=2) {
      const bx = wrap(buildingSeeds[i] * W * 2 + panX * 0.05) % W;
      const bh = buildingSeeds[i+1];
      const bw = 30 + buildingSeeds[i]*50;
      ctx.fillRect(bx, horizon - bh, bw, bh);
    }
    // Neon window glow dots
    const neonColors = ['#ff00ff','#00ffff','#ff3300','#aaff00','#ff99ff'];
    for (let w = 0; w < 40; w++) {
      const wx = wrap((w * 137.5 % 100 / 100) * W * 2 + panX * 0.05) % W;
      const wy = horizon - 20 - (w * 53 % 90);
      if (wy < 0 || wy > horizon) continue;
      const col2 = neonColors[w % neonColors.length];
      ctx.fillStyle = col2;
      ctx.shadowColor = col2; ctx.shadowBlur = 6;
      ctx.fillRect(wx, wy, 3, 3);
    }
    ctx.shadowBlur = 0;
    // Neon sign glow on horizon
    const neonGrad = ctx.createLinearGradient(0, horizon*0.6, 0, horizon);
    neonGrad.addColorStop(0, 'rgba(180,0,255,0.0)');
    neonGrad.addColorStop(1, 'rgba(180,0,255,0.12)');
    ctx.fillStyle = neonGrad; ctx.fillRect(0, horizon*0.6, W, horizon*0.4);

  } else if (idx === 3) {
    // ‚îÄ‚îÄ ALPINE PASS: dramatic snow peaks + pine trees + moon ‚îÄ‚îÄ
    // Moon
    const moonX = wrap(W * 0.8 + panX * 0.01);
    ctx.fillStyle = '#e8eeff';
    ctx.shadowColor = '#aabbff'; ctx.shadowBlur = 20;
    ctx.beginPath(); ctx.arc(moonX, horizon * 0.2, 28, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    // Moon craters
    ctx.fillStyle = 'rgba(0,0,50,0.12)';
    ctx.beginPath(); ctx.arc(moonX+8, horizon*0.2-5, 7, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(moonX-9, horizon*0.2+7, 4, 0, Math.PI*2); ctx.fill();

    // Far mountain range (dark blue)
    ctx.fillStyle = '#0d1520';
    ctx.beginPath(); ctx.moveTo(-W*0.1, horizon);
    for (let i = 0; i <= 30; i++) {
      const x = (i/30)*W*1.2-W*0.1 + (panX*0.04)%(W*1.2);
      const y = horizon - 60 + Math.sin(i*0.5+1)*55 + Math.cos(i*0.3)*30;
      i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.lineTo(W*1.2, horizon); ctx.closePath(); ctx.fill();

    // Mid snow peaks
    ctx.fillStyle = '#1a2a3a';
    ctx.beginPath(); ctx.moveTo(-W*0.1, horizon);
    const peakData = [0,0.08,0.18,0.28,0.38,0.5,0.62,0.73,0.84,0.95,1.06];
    for (let i = 0; i < peakData.length; i++) {
      const bx = wrap(peakData[i] * W + panX * 0.08) % W;
      const ph = 55 + Math.sin(i*2.1)*35;
      if (i>0) { ctx.lineTo(bx - 40, horizon); ctx.lineTo(bx, horizon - ph); ctx.lineTo(bx + 40, horizon); }
    }
    ctx.lineTo(W*1.1, horizon); ctx.closePath(); ctx.fill();

    // Snow caps on peaks
    ctx.fillStyle = 'rgba(220,235,255,0.85)';
    for (let i = 0; i < peakData.length-1; i++) {
      const bx = wrap(peakData[i] * W + panX * 0.08) % W;
      const ph = 55 + Math.sin(i*2.1)*35;
      ctx.beginPath(); ctx.moveTo(bx, horizon-ph); ctx.lineTo(bx-14, horizon-ph+18); ctx.lineTo(bx+14, horizon-ph+18); ctx.closePath(); ctx.fill();
    }

    // Pine trees silhouette
    ctx.fillStyle = '#0a1508';
    for (let t = 0; t < 28; t++) {
      const tx = wrap((t/28)*W*2 + panX*0.15) % W;
      const th = 28 + (t*7%15);
      ctx.beginPath();
      ctx.moveTo(tx, horizon); ctx.lineTo(tx-10, horizon-th*0.4);
      ctx.lineTo(tx-7, horizon-th*0.4); ctx.lineTo(tx-12, horizon-th*0.7);
      ctx.lineTo(tx-5, horizon-th*0.7); ctx.lineTo(tx, horizon-th);
      ctx.lineTo(tx+5, horizon-th*0.7); ctx.lineTo(tx+12, horizon-th*0.7);
      ctx.lineTo(tx+7, horizon-th*0.4); ctx.lineTo(tx+10, horizon-th*0.4);
      ctx.closePath(); ctx.fill();
    }
    // Snow on ground near horizon
    const snowGrad = ctx.createLinearGradient(0, horizon-12, 0, horizon+2);
    snowGrad.addColorStop(0, 'rgba(220,235,255,0.0)');
    snowGrad.addColorStop(1, 'rgba(220,235,255,0.25)');
    ctx.fillStyle = snowGrad; ctx.fillRect(0, horizon-12, W, 14);

  } else if (idx === 4) {
    // ‚îÄ‚îÄ VOLCANO RUN: erupting volcano + lava glow + ash clouds ‚îÄ‚îÄ
    // Volcano silhouette
    const volcX = wrap(W * 0.55 + panX * 0.03);
    ctx.fillStyle = '#1a0500';
    ctx.beginPath();
    ctx.moveTo(volcX - 280, horizon);
    ctx.lineTo(volcX - 60, horizon - 180);
    ctx.lineTo(volcX, horizon - 220);
    ctx.lineTo(volcX + 60, horizon - 180);
    ctx.lineTo(volcX + 280, horizon);
    ctx.closePath(); ctx.fill();

    // Lava glow at crater
    const lavaGrad = ctx.createRadialGradient(volcX, horizon-218, 0, volcX, horizon-200, 80);
    lavaGrad.addColorStop(0, 'rgba(255,160,0,0.9)');
    lavaGrad.addColorStop(0.3, 'rgba(255,60,0,0.5)');
    lavaGrad.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = lavaGrad; ctx.fillRect(volcX-80, horizon-300, 160, 120);

    // Lava particles shooting up
    const lt = Date.now() * 0.001;
    for (let p = 0; p < 18; p++) {
      const pt = (lt * 0.8 + p * 0.37) % 1;
      const px2 = volcX + Math.sin(p * 2.1) * 30 * pt;
      const py2 = horizon - 218 - pt * 140 + pt*pt*80;
      const ps = (1-pt) * 5;
      ctx.fillStyle = `rgba(255,${Math.floor(100*(1-pt))},0,${(1-pt)*0.9})`;
      ctx.beginPath(); ctx.arc(px2, py2, ps, 0, Math.PI*2); ctx.fill();
    }

    // Ash clouds
    ctx.fillStyle = 'rgba(60,40,30,0.3)';
    const ashClouds = [[0.2,0.15,70],[0.4,0.25,90],[0.6,0.1,55],[0.8,0.3,80]];
    for (const [fx, fy, cw] of ashClouds) {
      const ax = wrap(fx * W + panX * 0.09) % W;
      const ay = horizon * fy;
      ctx.beginPath(); ctx.ellipse(ax, ay, cw, cw*0.4, 0, 0, Math.PI*2); ctx.fill();
    }

    // Lava horizon glow
    const lavaHorizon = ctx.createLinearGradient(0, horizon-40, 0, horizon+10);
    lavaHorizon.addColorStop(0, 'rgba(255,50,0,0.0)');
    lavaHorizon.addColorStop(0.5, 'rgba(255,80,0,0.18)');
    lavaHorizon.addColorStop(1, 'rgba(255,120,0,0.3)');
    ctx.fillStyle = lavaHorizon; ctx.fillRect(0, horizon-40, W, 50);

    // Ember sparks floating
    const et = Date.now() * 0.0008;
    for (let e = 0; e < 12; e++) {
      const ex = (((e * 137 + et * 40) % W) + W) % W;
      const ey = horizon * (0.4 + ((e * 53 + et * 0.3) % 0.5));
      ctx.fillStyle = `rgba(255,${Math.floor(100+e*8)},0,${0.4+Math.sin(et+e)*0.3})`;
      ctx.beginPath(); ctx.arc(ex, ey, 1.5, 0, Math.PI*2); ctx.fill();
    }
  }

  ctx.restore();
}

  // Ground
  const groundGrad = ctx.createLinearGradient(0, horizon, 0, H);
  groundGrad.addColorStop(0, course.groundColor);
  groundGrad.addColorStop(1, shadeColor2(course.groundColor, -0.4));
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, horizon, W, H - horizon);

  // Cast rays for walls
  const colW = W / NUM_RAYS;
  const rosterK = KART_ROSTER[selectedKartIdx];

  for (let col = 0; col < NUM_RAYS; col++) {
    const rayAngle = pa - FOV / 2 + (col / NUM_RAYS) * FOV;
    const { dist: rawDist, onOuter } = castRay(px, py, rayAngle);

    // Fix fisheye
    const dist = rawDist * Math.cos(rayAngle - pa);

    const wallH = Math.min(H * 2, WALL_HEIGHT_SCALE / dist);
    const wallTop = horizon - wallH * (1 - CAM_HEIGHT);
    const wallBot = horizon + wallH * CAM_HEIGHT;

    const bright = Math.max(0, Math.min(1, 1 - dist / MAX_DIST));

    // Parse course wall color
    const wc = course.wallColor;
    let wr2 = parseInt(wc.slice(1,2),16)*17, wg2 = parseInt(wc.slice(3,4),16)*17, wb2 = parseInt(wc.slice(5,6),16)*17;
    if (wc.length === 7) { wr2 = parseInt(wc.slice(1,3),16); wg2 = parseInt(wc.slice(3,5),16); wb2 = parseInt(wc.slice(5,7),16); }
    const wallColor = `rgb(${Math.floor(wr2*bright)},${Math.floor(wg2*bright)},${Math.floor(wb2*bright)})`;

    // Curb stripes
    const worldX = px + Math.cos(rayAngle) * rawDist;
    const worldY = py + Math.sin(rayAngle) * rawDist;
    const stripeIdx = Math.floor(Math.hypot(worldX, worldY) / 80);
    const isRed = stripeIdx % 2 === 0;
    const curbColor = isRed
      ? `rgb(${Math.floor(220*bright)},${Math.floor(40*bright)},${Math.floor(40*bright)})`
      : wallColor;

    ctx.fillStyle = curbColor;
    ctx.fillRect(col * colW, wallTop, colW + 1, wallBot - wallTop);

    // Road surface strip
    const roadH = wallH * 0.08;
    ctx.fillStyle = `rgb(${Math.floor(80*bright+20)},${Math.floor(80*bright+20)},${Math.floor(80*bright+20)})`;
    ctx.fillRect(col * colW, wallBot - roadH, colW + 1, roadH);
  }

  // Draw floor road markings (center line) using floor projection
  drawFloorMarkings(pa, horizon);

  // Draw other karts as billboards
  drawKartBillboards(pa, horizon);

  // Draw player kart cockpit overlay
  drawCockpit(rosterK);
}

function drawFloorMarkings(pa, horizon) {
  ctx.save();
  const { seg } = getClosestTrack(player.x, player.y);

  // ‚îÄ‚îÄ Center line dashes ‚îÄ‚îÄ
  for (let si = 0; si < 20; si++) {
    const idx = (seg + si) % trackPoints.length;
    const tp = trackPoints[idx];
    const dx = tp.x - player.x, dy = tp.y - player.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 5 || dist > 900) continue;
    const angleTo = Math.atan2(dy, dx);
    let da = angleTo - pa;
    while (da > Math.PI) da -= Math.PI * 2;
    while (da < -Math.PI) da += Math.PI * 2;
    if (Math.abs(da) > FOV / 2 * 1.1) continue;
    const screenX = W / 2 + (da / (FOV / 2)) * (W / 2);
    const fixedDist = dist * Math.cos(da);
    const scale = WALL_HEIGHT_SCALE / fixedDist;
    const screenY = horizon + scale * CAM_HEIGHT * 0.05;
    const size = Math.max(2, 80 / fixedDist * 8);
    ctx.globalAlpha = Math.max(0, 1 - dist / 700) * 0.55;
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillRect(screenX - size / 2, screenY - size * 0.3, size, size * 0.15);
  }
  ctx.globalAlpha = 1;

  // ‚îÄ‚îÄ Finish line ‚îÄ‚îÄ
  // Finish line is at trackPoints[0]. Project it as a wide band across the track.
  const fl = trackPoints[0];
  const flNext = trackPoints[1];
  const flAngle = Math.atan2(flNext.y - fl.y, flNext.x - fl.x);
  const flPerp = flAngle + Math.PI / 2;

  // Sample 24 checker squares across the finish line width
  const CHECKERS = 16;
  for (let ci = 0; ci < CHECKERS; ci++) {
    const t = (ci / CHECKERS - 0.5) * TRACK_WIDTH * 0.92;
    // Two rows (near and far edge of the band, ~80 units wide)
    for (let row = 0; row < 2; row++) {
      const fwd = row * 80;
      const wx = fl.x + Math.cos(flPerp) * t + Math.cos(flAngle) * fwd;
      const wy = fl.y + Math.sin(flPerp) * t + Math.sin(flAngle) * fwd;
      const dx = wx - player.x, dy2 = wy - player.y;
      const dist = Math.hypot(dx, dy2);
      if (dist < 5 || dist > 1400) continue;
      const angleTo = Math.atan2(dy2, dx);
      let da = angleTo - pa;
      while (da > Math.PI) da -= Math.PI * 2;
      while (da < -Math.PI) da += Math.PI * 2;
      if (Math.abs(da) > FOV / 2 * 1.15) continue;
      const screenX = W / 2 + (da / (FOV / 2)) * (W / 2);
      const fixedDist = dist * Math.cos(da);
      const scale = WALL_HEIGHT_SCALE / fixedDist;
      const screenY = horizon + scale * CAM_HEIGHT * 0.05;
      const sz = Math.max(3, (TRACK_WIDTH / CHECKERS) / fixedDist * WALL_HEIGHT_SCALE * 0.052);
      const isBlack = (ci + row) % 2 === 0;
      ctx.globalAlpha = Math.max(0, 1 - dist / 1200) * 0.20;
      ctx.fillStyle = isBlack ? '#000' : '#fff';
      ctx.fillRect(screenX - sz / 2, screenY - sz * 0.4, sz, sz * 0.6);
    }
  }

  // Finish line gantry arch (if close enough)
  const flDist = Math.hypot(fl.x - player.x, fl.y - player.y);
  if (flDist < 900) {
    const flAngleTo = Math.atan2(fl.y - player.y, fl.x - player.x);
    let flDa = flAngleTo - pa;
    while (flDa > Math.PI) flDa -= Math.PI * 2;
    while (flDa < -Math.PI) flDa += Math.PI * 2;
    if (Math.abs(flDa) < FOV / 2 * 1.3) {
      const flFixedDist = flDist * Math.cos(flDa);
      const flScale = WALL_HEIGHT_SCALE / flFixedDist;
      const flScreenX = W / 2 + (flDa / (FOV / 2)) * (W / 2);
      const flScreenY = horizon - flScale * (1 - CAM_HEIGHT) * 0.05;
      const gantryW = (TRACK_WIDTH / flFixedDist) * WALL_HEIGHT_SCALE * 0.08;
      const gantryH = gantryW * 0.35;
      const bright = Math.max(0, 1 - flDist / 900);

      ctx.globalAlpha = bright;
      // Gantry arch body
      ctx.fillStyle = '#222';
      ctx.fillRect(flScreenX - gantryW / 2, flScreenY - gantryH, gantryW, gantryH * 0.18);
      // Left post
      ctx.fillStyle = '#333';
      ctx.fillRect(flScreenX - gantryW / 2, flScreenY - gantryH, gantryW * 0.06, gantryH);
      // Right post
      ctx.fillRect(flScreenX + gantryW / 2 - gantryW * 0.06, flScreenY - gantryH, gantryW * 0.06, gantryH);
      // FINISH text on banner
      ctx.fillStyle = '#f7c948';
      ctx.shadowColor = '#f7c948'; ctx.shadowBlur = 8;
      ctx.font = `bold ${Math.max(10, gantryH * 0.55)}px Russo One, sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('FINISH', flScreenX, flScreenY - gantryH * 0.55);
      // Checkered banner edges
      for (let bi = 0; bi < 10; bi++) {
        const bx = flScreenX - gantryW * 0.44 + bi * gantryW * 0.088;
        ctx.fillStyle = bi % 2 === 0 ? '#fff' : '#000';
        ctx.fillRect(bx, flScreenY - gantryH, gantryW * 0.088, gantryH * 0.18);
      }
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    }
  }

  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawKartBillboards(pa, horizon) {
  const cpuKarts = karts.filter(k => !k.isPlayer)
    .map(k => {
      const dx = k.x - player.x, dy = k.y - player.y;
      return { k, dist: Math.hypot(dx, dy), dx, dy };
    })
    .sort((a, b) => b.dist - a.dist);

  for (const { k, dist, dx, dy } of cpuKarts) {
    if (dist < 10 || dist > 1100) continue;
    const angleTo = Math.atan2(dy, dx);
    let da = angleTo - pa;
    while (da > Math.PI) da -= Math.PI * 2;
    while (da < -Math.PI) da += Math.PI * 2;
    if (Math.abs(da) > FOV / 2 * 1.25) continue;

    const screenX = W / 2 + (da / (FOV / 2)) * (W / 2);
    const fixedDist = dist * Math.cos(da);
    const scale = WALL_HEIGHT_SCALE / fixedDist;

    // Base unit size
    const U = scale * 0.00018;
    const KW = U * 220;   // kart width
    const KH = U * 120;   // kart body height
    const KL = KW * 0.75; // kart length (perspective foreshortened)

    // Vertical offset: sit on floor
    const baseY = horizon + scale * CAM_HEIGHT * 0.012;
    const bright = Math.max(0.15, 1 - dist / 900);

    // Angle difference between kart heading and viewer
    let relAngle = k.angle - player.angle;
    while (relAngle > Math.PI) relAngle -= Math.PI * 2;
    while (relAngle < -Math.PI) relAngle += Math.PI * 2;
    const showingFront = Math.abs(relAngle) > Math.PI * 0.6;
    const showingBack  = Math.abs(relAngle) < Math.PI * 0.4;
    // 0 = side view, 1 = front/back view
    const frontFrac = Math.max(0, (Math.abs(relAngle) - Math.PI * 0.4) / (Math.PI * 0.2));

    ctx.save();
    ctx.globalAlpha = bright;
    ctx.translate(screenX, baseY);

    // ‚îÄ Shadow on ground ‚îÄ
    ctx.globalAlpha = bright * 0.35;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(0, 2, KW * 0.55, KH * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = bright;

    // ‚îÄ Wheels (4 wheels, 3D perspective) ‚îÄ
    const wheelR = KH * 0.35;
    const wheelW = wheelR * 0.55;
    const wheelY = 0;
    const wheelOffX = KW * 0.46;
    const wheelOffZ = KL * 0.32; // front/back offset (perspective shift)

    // Back-left, Back-right, Front-left, Front-right
    // In side view show all 4 at corners
    const wheels = [
      { x: -wheelOffX - wheelW * 0.3, y: wheelY, perspective: -wheelOffZ },
      { x:  wheelOffX + wheelW * 0.3, y: wheelY, perspective: -wheelOffZ },
      { x: -wheelOffX - wheelW * 0.3, y: wheelY, perspective:  wheelOffZ },
      { x:  wheelOffX + wheelW * 0.3, y: wheelY, perspective:  wheelOffZ },
    ];

    for (const w of wheels) {
      const perspShift = w.perspective * frontFrac * 0.3;
      const wx = w.x + perspShift;
      // Tire
      ctx.fillStyle = '#1a1a1a';
      ctx.beginPath(); ctx.ellipse(wx, wheelY - wheelR * 0.5, wheelW * 0.5, wheelR, 0, 0, Math.PI * 2); ctx.fill();
      // Rim
      ctx.fillStyle = '#555';
      ctx.beginPath(); ctx.ellipse(wx, wheelY - wheelR * 0.5, wheelW * 0.28, wheelR * 0.65, 0, 0, Math.PI * 2); ctx.fill();
      // Rim spokes
      ctx.strokeStyle = '#888'; ctx.lineWidth = Math.max(0.5, wheelW * 0.06);
      for (let s = 0; s < 5; s++) {
        const sa = (s / 5) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(wx, wheelY - wheelR * 0.5);
        ctx.lineTo(wx + Math.cos(sa) * wheelW * 0.22, wheelY - wheelR * 0.5 + Math.sin(sa) * wheelR * 0.55);
        ctx.stroke();
      }
      // Rim center
      ctx.fillStyle = '#aaa';
      ctx.beginPath(); ctx.ellipse(wx, wheelY - wheelR * 0.5, wheelW * 0.08, wheelR * 0.1, 0, 0, Math.PI * 2); ctx.fill();
    }

    // ‚îÄ Side skirt / undercarriage ‚îÄ
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.roundRect(-KW * 0.5, -KH * 0.18, KW, KH * 0.18, 2); ctx.fill();

    // ‚îÄ Main body ‚îÄ
    // Lower body panel
    const bodyGrad = ctx.createLinearGradient(-KW * 0.5, -KH, KW * 0.5, 0);
    bodyGrad.addColorStop(0, k.color);
    bodyGrad.addColorStop(0.4, k.color);
    bodyGrad.addColorStop(1, shadeColor(k.color, -0.45));
    ctx.fillStyle = bodyGrad;
    ctx.beginPath(); ctx.roundRect(-KW * 0.5, -KH * 0.95, KW, KH * 0.78, [4, 4, 0, 0]); ctx.fill();

    // Body highlight (top edge)
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.roundRect(-KW * 0.48, -KH * 0.95, KW * 0.96, KH * 0.1, [4, 4, 0, 0]); ctx.fill();

    // ‚îÄ Cockpit / roll cage ‚îÄ
    const cockpitGrad = ctx.createLinearGradient(0, -KH * 1.4, 0, -KH * 0.85);
    cockpitGrad.addColorStop(0, shadeColor(k.color, -0.3));
    cockpitGrad.addColorStop(1, shadeColor(k.color, -0.5));
    ctx.fillStyle = cockpitGrad;
    ctx.beginPath();
    ctx.moveTo(-KW * 0.3, -KH * 0.9);
    ctx.lineTo(-KW * 0.25, -KH * 1.4);
    ctx.lineTo( KW * 0.25, -KH * 1.4);
    ctx.lineTo( KW * 0.3,  -KH * 0.9);
    ctx.closePath(); ctx.fill();

    // ‚îÄ Windshield ‚îÄ
    ctx.fillStyle = 'rgba(140,200,255,0.35)';
    ctx.strokeStyle = 'rgba(200,230,255,0.5)'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-KW * 0.22, -KH * 0.92);
    ctx.lineTo(-KW * 0.18, -KH * 1.35);
    ctx.lineTo( KW * 0.18, -KH * 1.35);
    ctx.lineTo( KW * 0.22, -KH * 0.92);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    // Glass glare
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.moveTo(-KW * 0.19, -KH * 0.94);
    ctx.lineTo(-KW * 0.08, -KH * 1.32);
    ctx.lineTo(-KW * 0.01, -KH * 1.32);
    ctx.lineTo(-KW * 0.12, -KH * 0.94);
    ctx.closePath(); ctx.fill();

    // ‚îÄ Helmet in cockpit ‚îÄ
    if (dist < 500) {
      ctx.fillStyle = k.accentColor;
      ctx.beginPath(); ctx.ellipse(0, -KH * 1.22, KW * 0.1, KH * 0.16, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.beginPath(); ctx.ellipse(KW * 0.02, -KH * 1.18, KW * 0.06, KH * 0.07, 0.2, 0, Math.PI * 2); ctx.fill();
    }

    // ‚îÄ Rear spoiler ‚îÄ
    ctx.fillStyle = shadeColor(k.color, -0.3);
    ctx.beginPath(); ctx.roundRect(-KW * 0.42, -KH * 1.1, KW * 0.84, KH * 0.1, 2); ctx.fill();
    // Spoiler endplates
    ctx.fillRect(-KW * 0.44, -KH * 1.25, KW * 0.06, KH * 0.15);
    ctx.fillRect( KW * 0.38, -KH * 1.25, KW * 0.06, KH * 0.15);

    // ‚îÄ Accent stripe ‚îÄ
    ctx.fillStyle = k.accentColor;
    ctx.globalAlpha = bright * 0.8;
    ctx.beginPath(); ctx.roundRect(-KW * 0.5, -KH * 0.55, KW, KH * 0.1, 1); ctx.fill();

    // ‚îÄ Headlights / taillights ‚îÄ
    if (showingFront || Math.abs(relAngle) > Math.PI * 0.5) {
      const isBack = relAngle < 0 ? relAngle > -Math.PI * 0.5 : relAngle < Math.PI * 0.5;
      // Taillights (red)
      ctx.fillStyle = '#e74c3c';
      ctx.shadowColor = '#e74c3c'; ctx.shadowBlur = 6;
      ctx.globalAlpha = bright * 0.9;
      ctx.beginPath(); ctx.roundRect(-KW * 0.45, -KH * 0.75, KW * 0.12, KH * 0.12, 2); ctx.fill();
      ctx.beginPath(); ctx.roundRect( KW * 0.33, -KH * 0.75, KW * 0.12, KH * 0.12, 2); ctx.fill();
      ctx.shadowBlur = 0;
    }

    // ‚îÄ Number plate ‚îÄ
    if (dist < 350) {
      ctx.globalAlpha = bright;
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.roundRect(-KW * 0.14, -KH * 0.5, KW * 0.28, KH * 0.22, 2); ctx.fill();
      ctx.fillStyle = '#222';
      ctx.font = `bold ${KH * 0.18}px Orbitron, monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(k.name.replace('CPU',''), 0, -KH * 0.32);
    }

    // ‚îÄ Name label above kart ‚îÄ
    ctx.globalAlpha = bright * 0.9;
    ctx.fillStyle = k.color;
    ctx.shadowColor = '#000'; ctx.shadowBlur = 4;
    ctx.font = `bold ${Math.max(9, KH * 0.38)}px Orbitron, monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(k.name, 0, -KH * 1.65);
    ctx.shadowBlur = 0;

    ctx.restore();
  }
}

// Utility: darken/lighten a hex color by fraction
function shadeColor(hex, frac) {
  let r = parseInt(hex.slice(1,3),16);
  let g = parseInt(hex.slice(3,5),16);
  let b = parseInt(hex.slice(5,7),16);
  r = Math.max(0, Math.min(255, Math.round(r + r * frac)));
  g = Math.max(0, Math.min(255, Math.round(g + g * frac)));
  b = Math.max(0, Math.min(255, Math.round(b + b * frac)));
  return `rgb(${r},${g},${b})`;
}

function shadeColor2(color, frac) {
  // Works with both #rrggbb and rgb(...) strings
  if (color.startsWith('#')) return shadeColor(color, frac);
  const m = color.match(/\d+/g);
  if (!m) return color;
  const r = Math.max(0, Math.min(255, Math.round(+m[0] * (1 + frac))));
  const g = Math.max(0, Math.min(255, Math.round(+m[1] * (1 + frac))));
  const b = Math.max(0, Math.min(255, Math.round(+m[2] * (1 + frac))));
  return `rgb(${r},${g},${b})`;
}

function drawCockpit(rosterK) {
  const cx = W / 2;
  const steerTarget = (keys['ArrowLeft'] || keys['KeyA']) ? -0.28
                    : (keys['ArrowRight'] || keys['KeyD']) ? 0.28 : 0;
  if (!drawCockpit._steer) drawCockpit._steer = 0;
  drawCockpit._steer += (steerTarget - drawCockpit._steer) * 0.14;
  const steer = drawCockpit._steer;
  const speed = Math.abs(player.speed);
  const speedFrac = speed / player.maxSpeed;
  const now = Date.now();
  const ac = rosterK.accentColor;
  const bc = rosterK.bodyColor;

  // ‚îÄ‚îÄ‚îÄ WINDSHIELD FRAME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Deep angled side panels like a racing cockpit
  ctx.save();
  const leftPanel = ctx.createLinearGradient(0, 0, W*0.22, 0);
  leftPanel.addColorStop(0, '#000');
  leftPanel.addColorStop(0.7, '#111');
  leftPanel.addColorStop(1, 'rgba(18,18,20,0)');
  ctx.fillStyle = leftPanel;
  ctx.beginPath();
  ctx.moveTo(0, 0); ctx.lineTo(W*0.22, 0);
  ctx.lineTo(W*0.12, H*0.58); ctx.lineTo(0, H*0.65);
  ctx.closePath(); ctx.fill();

  const rightPanel = ctx.createLinearGradient(W, 0, W*0.78, 0);
  rightPanel.addColorStop(0, '#000');
  rightPanel.addColorStop(0.7, '#111');
  rightPanel.addColorStop(1, 'rgba(18,18,20,0)');
  ctx.fillStyle = rightPanel;
  ctx.beginPath();
  ctx.moveTo(W, 0); ctx.lineTo(W*0.78, 0);
  ctx.lineTo(W*0.88, H*0.58); ctx.lineTo(W, H*0.65);
  ctx.closePath(); ctx.fill();

  // Thin glowing A-pillar edge lines
  ctx.lineWidth = 1.5;
  ctx.shadowBlur = 10;
  ctx.shadowColor = ac;
  ctx.strokeStyle = ac;
  ctx.globalAlpha = 0.35;
  ctx.beginPath(); ctx.moveTo(W*0.21, 0); ctx.lineTo(W*0.115, H*0.575); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(W*0.79, 0); ctx.lineTo(W*0.885, H*0.575); ctx.stroke();
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ MAIN DASHBOARD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.save();
  // Base: very dark, low-profile wedge shape
  const dashBase = ctx.createLinearGradient(0, H*0.60, 0, H);
  dashBase.addColorStop(0, '#0d0d10');
  dashBase.addColorStop(0.25, '#0a0a0d');
  dashBase.addColorStop(1, '#050508');
  ctx.fillStyle = dashBase;
  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(0, H*0.78);
  ctx.bezierCurveTo(W*0.06, H*0.70, W*0.2, H*0.635, W*0.32, H*0.625);
  ctx.bezierCurveTo(W*0.42, H*0.618, W*0.46, H*0.608, cx, H*0.603);
  ctx.bezierCurveTo(W*0.54, H*0.608, W*0.58, H*0.618, W*0.68, H*0.625);
  ctx.bezierCurveTo(W*0.8, H*0.635, W*0.94, H*0.70, W, H*0.78);
  ctx.lineTo(W, H);
  ctx.closePath(); ctx.fill();

  // Carbon fibre texture (subtle diagonal hatching)
  ctx.strokeStyle = 'rgba(255,255,255,0.018)';
  ctx.lineWidth = 1;
  for (let i = -20; i < W+20; i += 8) {
    ctx.beginPath(); ctx.moveTo(i, H*0.60); ctx.lineTo(i+40, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(i+40, H*0.60); ctx.lineTo(i, H); ctx.stroke();
  }

  // Body-color top ridge strip
  const ridge = ctx.createLinearGradient(0, H*0.598, 0, H*0.64);
  ridge.addColorStop(0, bc + 'cc');
  ridge.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = ridge;
  ctx.beginPath();
  ctx.moveTo(W*0.08, H*0.78);
  ctx.bezierCurveTo(W*0.15, H*0.665, W*0.28, H*0.630, W*0.36, H*0.626);
  ctx.bezierCurveTo(W*0.44, H*0.620, W*0.47, H*0.612, cx, H*0.607);
  ctx.bezierCurveTo(W*0.53, H*0.612, W*0.56, H*0.620, W*0.64, H*0.626);
  ctx.bezierCurveTo(W*0.72, H*0.630, W*0.85, H*0.665, W*0.92, H*0.78);
  ctx.bezierCurveTo(W*0.78, H*0.648, W*0.58, H*0.625, cx, H*0.617);
  ctx.bezierCurveTo(W*0.42, H*0.625, W*0.22, H*0.648, W*0.08, H*0.78);
  ctx.closePath(); ctx.fill();

  // HUD glow strip across top of dash
  ctx.shadowColor = ac; ctx.shadowBlur = 18;
  ctx.strokeStyle = ac; ctx.lineWidth = 1.5;
  ctx.globalAlpha = 0.6;
  ctx.beginPath();
  ctx.moveTo(W*0.15, H*0.745);
  ctx.bezierCurveTo(W*0.25, H*0.662, W*0.4, H*0.628, cx, H*0.620);
  ctx.bezierCurveTo(W*0.6, H*0.628, W*0.75, H*0.662, W*0.85, H*0.745);
  ctx.stroke();
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ HOLOGRAPHIC HUD DISPLAY (center dash) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.save();
  const hudY = H*0.70, hudH = H*0.095, hudW = W*0.28;
  const hudX = cx - hudW/2;

  // HUD screen glass
  const hudGlass = ctx.createLinearGradient(hudX, hudY, hudX, hudY+hudH);
  hudGlass.addColorStop(0, 'rgba(0,20,40,0.92)');
  hudGlass.addColorStop(1, 'rgba(0,10,20,0.88)');
  ctx.fillStyle = hudGlass;
  ctx.beginPath(); ctx.roundRect(hudX, hudY, hudW, hudH, 3); ctx.fill();

  // Screen border glow
  ctx.strokeStyle = ac; ctx.lineWidth = 1;
  ctx.shadowColor = ac; ctx.shadowBlur = 8;
  ctx.globalAlpha = 0.7;
  ctx.beginPath(); ctx.roundRect(hudX, hudY, hudW, hudH, 3); ctx.stroke();
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;

  // Screen scanline effect
  ctx.fillStyle = 'rgba(255,255,255,0.012)';
  for (let sl = 0; sl < hudH; sl += 3) {
    ctx.fillRect(hudX, hudY + sl, hudW, 1);
  }

  // Speed readout ‚Äî big digital number
  const kmh = Math.abs(Math.round(speed * 12));
  ctx.fillStyle = ac;
  ctx.shadowColor = ac; ctx.shadowBlur = 12;
  ctx.font = `bold ${hudH*0.55}px Orbitron, monospace`;
  ctx.textAlign = 'right';
  ctx.fillText(kmh, hudX + hudW*0.62, hudY + hudH*0.65);
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = `${hudH*0.22}px Orbitron, monospace`;
  ctx.fillText('KM/H', hudX + hudW*0.62, hudY + hudH*0.88);

  // Gear readout
  const gear = speed < 0.5 ? 'N' : speed < player.maxSpeed*0.2 ? '1'
    : speed < player.maxSpeed*0.4 ? '2' : speed < player.maxSpeed*0.6 ? '3'
    : speed < player.maxSpeed*0.8 ? '4' : '5';
  ctx.fillStyle = gear === 'N' ? '#aaa' : '#2ecc71';
  ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 10;
  ctx.font = `bold ${hudH*0.6}px Orbitron, monospace`;
  ctx.textAlign = 'center';
  ctx.fillText(gear, hudX + hudW*0.83, hudY + hudH*0.68);
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = `${hudH*0.18}px Orbitron, monospace`;
  ctx.fillText('GEAR', hudX + hudW*0.83, hudY + hudH*0.88);

  // Thin divider
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(hudX + hudW*0.7, hudY+4); ctx.lineTo(hudX+hudW*0.7, hudY+hudH-4); ctx.stroke();

  // Lap counter (small top-left of HUD)
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.font = `${hudH*0.2}px Orbitron, monospace`;
  ctx.textAlign = 'left';
  ctx.fillText(`LAP ${Math.min(player.lap, TOTAL_LAPS)}/${TOTAL_LAPS}`, hudX+6, hudY + hudH*0.28);

  // Position
  const pos = ['1ST','2ND','3RD','4TH','5TH'][getRacePosition()-1];
  ctx.fillStyle = pos === '1ST' ? '#f7c948' : 'rgba(255,255,255,0.5)';
  ctx.font = `bold ${hudH*0.28}px Orbitron, monospace`;
  ctx.fillText(pos, hudX+6, hudY + hudH*0.58);

  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ SPEED BAR (left side of dash) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.save();
  const barX = cx - W*0.22, barY = H*0.685, barW = W*0.07, barH = H*0.09;
  // Background track
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH*0.06, 2); ctx.fill();
  // Fill
  const speedColor = speedFrac > 0.85 ? '#e74c3c' : speedFrac > 0.6 ? '#f7c948' : ac;
  const speedBarGrad = ctx.createLinearGradient(barX, 0, barX+barW*speedFrac, 0);
  speedBarGrad.addColorStop(0, speedColor + '88');
  speedBarGrad.addColorStop(1, speedColor);
  ctx.fillStyle = speedBarGrad;
  ctx.shadowColor = speedColor; ctx.shadowBlur = 6;
  ctx.beginPath(); ctx.roundRect(barX, barY, barW*speedFrac, barH*0.06, 2); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.font = `${barH*0.22}px Orbitron, monospace`;
  ctx.textAlign = 'center';
  ctx.fillText('THROTTLE', barX + barW/2, barY - 3);
  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ ABILITY PANEL (right side of dash) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.save();
  const cdFrac = Math.min((raceTime - player.abilityLastUsed) / player.abilityCooldown, 1);
  const abilReady = cdFrac >= 1;
  const abilActive = player.abilityActive;
  const apX = cx + W*0.15, apY = H*0.682, apW = W*0.075, apH = H*0.055;

  // Panel bg
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.beginPath(); ctx.roundRect(apX, apY, apW, apH, 3); ctx.fill();

  const abilColor = abilActive ? ac : abilReady ? '#2ecc71' : '#334';
  ctx.strokeStyle = abilColor; ctx.lineWidth = 1;
  ctx.shadowColor = abilColor; ctx.shadowBlur = abilReady || abilActive ? 10 : 0;
  ctx.globalAlpha = abilReady || abilActive ? 0.9 : 0.4;
  ctx.beginPath(); ctx.roundRect(apX, apY, apW, apH, 3); ctx.stroke();
  ctx.shadowBlur = 0;

  // CD fill bar
  ctx.fillStyle = abilColor + '33';
  ctx.beginPath(); ctx.roundRect(apX, apY + apH*(1-cdFrac), apW, apH*cdFrac, [0,0,3,3]); ctx.fill();

  ctx.globalAlpha = 1;
  const abilIcon = KART_ROSTER[selectedKartIdx].ability.icon;
  ctx.font = `${apH*0.45}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(abilIcon, apX + apW/2, apY + apH*0.55);
  ctx.fillStyle = abilReady || abilActive ? abilColor : '#555';
  ctx.font = `bold ${apH*0.2}px Orbitron, monospace`;
  ctx.shadowColor = abilColor; ctx.shadowBlur = abilReady ? 6 : 0;
  ctx.fillText(abilActive ? 'ACTIVE' : abilReady ? '[E] USE' : `${((1-cdFrac)*player.abilityCooldown/1000).toFixed(1)}s`, apX+apW/2, apY+apH*0.92);
  ctx.shadowBlur = 0;
  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ STEERING WHEEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.save();
  ctx.translate(cx, H*0.90);
  ctx.rotate(steer * 1.6);

  const wr = H * 0.105;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.beginPath(); ctx.ellipse(5, 8, wr*0.9, wr*0.22, 0, 0, Math.PI*2); ctx.fill();

  // ‚îÄ Flat-bottomed F1-style wheel ‚îÄ
  // Outer rim - thick, dark carbon
  const rimG = ctx.createLinearGradient(-wr, -wr*0.8, wr, wr*0.8);
  rimG.addColorStop(0, '#1e1e22');
  rimG.addColorStop(0.3, '#2a2a30');
  rimG.addColorStop(0.7, '#18181c');
  rimG.addColorStop(1, '#0e0e12');
  ctx.strokeStyle = rimG;
  ctx.lineWidth = wr * 0.20;
  ctx.lineCap = 'butt';

  // Draw mostly round but clip flat at bottom (F1 style)
  ctx.save();
  ctx.beginPath(); ctx.rect(-wr*1.5, -wr*1.5, wr*3, wr*1.7); ctx.clip(); // clip top portion
  ctx.beginPath(); ctx.arc(0, 0, wr, 0, Math.PI*2); ctx.stroke();
  ctx.restore();
  // flat bottom bar
  ctx.strokeStyle = rimG; ctx.lineWidth = wr*0.20;
  ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(-wr*0.82, wr*0.47); ctx.lineTo(wr*0.82, wr*0.47); ctx.stroke();

  // Accent glow band on top of rim
  ctx.strokeStyle = ac; ctx.lineWidth = wr*0.06;
  ctx.shadowColor = ac; ctx.shadowBlur = 14;
  ctx.globalAlpha = 0.8;
  ctx.save();
  ctx.beginPath(); ctx.rect(-wr*1.5, -wr*1.5, wr*3, wr*0.9); ctx.clip();
  ctx.beginPath(); ctx.arc(0, 0, wr, 0, Math.PI*2); ctx.stroke();
  ctx.restore();
  ctx.shadowBlur = 0; ctx.globalAlpha = 1;

  // Inner rim edge highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 1;
  ctx.save();
  ctx.beginPath(); ctx.rect(-wr*1.5, -wr*1.5, wr*3, wr*1.6); ctx.clip();
  ctx.beginPath(); ctx.arc(0, 0, wr*0.88, 0, Math.PI*2); ctx.stroke();
  ctx.restore();

  // ‚îÄ 3 spokes (F1 triangular) ‚îÄ
  const spokeAngles = [-Math.PI/2, -Math.PI/2 + Math.PI*2/3, -Math.PI/2 + Math.PI*4/3];
  for (const a of spokeAngles) {
    const sx = Math.cos(a), sy = Math.sin(a);
    ctx.save();
    ctx.translate(sx*wr*0.5, sy*wr*0.5);
    ctx.rotate(a);
    // Tapered spoke shape
    const spG = ctx.createLinearGradient(0, -wr*0.45, 0, wr*0.45);
    spG.addColorStop(0, '#2a2a30');
    spG.addColorStop(0.5, '#1a1a20');
    spG.addColorStop(1, '#111115');
    ctx.fillStyle = spG;
    ctx.beginPath();
    ctx.moveTo(-wr*0.065, -wr*0.45);
    ctx.lineTo( wr*0.065, -wr*0.45);
    ctx.lineTo( wr*0.04,   wr*0.45);
    ctx.lineTo(-wr*0.04,   wr*0.45);
    ctx.closePath(); ctx.fill();
    // Spoke highlight
    ctx.strokeStyle = 'rgba(255,255,255,0.07)'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(-wr*0.025,-wr*0.42); ctx.lineTo(-wr*0.015, wr*0.42); ctx.stroke();
    ctx.restore();
  }

  // ‚îÄ Center hub display ‚îÄ
  const hubG = ctx.createRadialGradient(0, -wr*0.06, 0, 0, 0, wr*0.25);
  hubG.addColorStop(0, '#2a2a35');
  hubG.addColorStop(0.5, '#141418');
  hubG.addColorStop(1, '#0a0a0d');
  ctx.fillStyle = hubG;
  ctx.beginPath(); ctx.arc(0, 0, wr*0.25, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = ac; ctx.lineWidth = 1.5;
  ctx.shadowColor = ac; ctx.shadowBlur = 8;
  ctx.beginPath(); ctx.arc(0, 0, wr*0.25, 0, Math.PI*2); ctx.stroke();
  ctx.shadowBlur = 0;

  // Hub: kart logo initial
  ctx.fillStyle = ac;
  ctx.shadowColor = ac; ctx.shadowBlur = 10;
  ctx.font = `bold ${wr*0.18}px Orbitron, monospace`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(rosterK.name[0], 0, 0);
  ctx.shadowBlur = 0; ctx.textBaseline = 'alphabetic';

  // ‚îÄ Thumb grips (rubber texture) ‚îÄ
  for (const side of [-1, 1]) {
    ctx.save();
    ctx.translate(side * wr * 0.72, wr*0.05);
    const gripG = ctx.createLinearGradient(-wr*0.14, 0, wr*0.14, 0);
    gripG.addColorStop(0, '#1a1a1a');
    gripG.addColorStop(0.5, '#252525');
    gripG.addColorStop(1, '#1a1a1a');
    ctx.fillStyle = gripG;
    ctx.beginPath(); ctx.roundRect(-wr*0.13, -wr*0.16, wr*0.26, wr*0.32, wr*0.04); ctx.fill();
    // Grip ridges
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 1.5;
    for (let g = 0; g < 3; g++) {
      ctx.beginPath();
      ctx.moveTo(-wr*0.09, -wr*0.09 + g*wr*0.09);
      ctx.lineTo( wr*0.09, -wr*0.09 + g*wr*0.09);
      ctx.stroke();
    }
    ctx.restore();
  }

  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ REARVIEW MIRROR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  ctx.save();
  const mirW = W*0.14, mirH = H*0.048;
  const mirX = cx - mirW/2, mirY = H*0.588;

  // Chrome housing
  const mirHousing = ctx.createLinearGradient(mirX-4, mirY-3, mirX+mirW+4, mirY+mirH+3);
  mirHousing.addColorStop(0, '#333');
  mirHousing.addColorStop(0.5, '#555');
  mirHousing.addColorStop(1, '#222');
  ctx.fillStyle = mirHousing;
  ctx.beginPath(); ctx.roundRect(mirX-4, mirY-3, mirW+8, mirH+6, 4); ctx.fill();

  // Glass
  const course = COURSES[selectedCourseIdx] || COURSES[0];
  const mirG = ctx.createLinearGradient(mirX, mirY, mirX, mirY+mirH);
  mirG.addColorStop(0, course.skyTop);
  mirG.addColorStop(0.5, course.skyBot);
  mirG.addColorStop(0.52, course.groundColor);
  mirG.addColorStop(1, shadeColor2(course.groundColor, -0.3));
  ctx.fillStyle = mirG;
  ctx.beginPath(); ctx.roundRect(mirX, mirY, mirW, mirH, 2); ctx.fill();

  // Fish-eye warp gradient
  const fishEye = ctx.createRadialGradient(mirX+mirW/2, mirY+mirH/2, 0, mirX+mirW/2, mirY+mirH/2, mirW*0.55);
  fishEye.addColorStop(0, 'rgba(255,255,255,0.04)');
  fishEye.addColorStop(1, 'rgba(0,0,0,0.25)');
  ctx.fillStyle = fishEye;
  ctx.beginPath(); ctx.roundRect(mirX, mirY, mirW, mirH, 2); ctx.fill();

  // Glare streak
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.save();
  ctx.beginPath(); ctx.roundRect(mirX, mirY, mirW, mirH, 2); ctx.clip();
  ctx.beginPath();
  ctx.moveTo(mirX+mirW*0.1, mirY); ctx.lineTo(mirX+mirW*0.35, mirY);
  ctx.lineTo(mirX+mirW*0.22, mirY+mirH); ctx.lineTo(mirX, mirY+mirH);
  ctx.fill();
  ctx.restore();

  // Mirror border glow
  ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(mirX, mirY, mirW, mirH, 2); ctx.stroke();
  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ WINDSHIELD EFFECTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Subtle HUD reflection / screen tint on glass
  ctx.save();
  const screenGlow = ctx.createLinearGradient(cx-W*0.3, H*0.0, cx+W*0.3, H*0.55);
  screenGlow.addColorStop(0, 'rgba(0,0,0,0)');
  screenGlow.addColorStop(0.5, 'rgba(0,0,0,0)');
  screenGlow.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = screenGlow;
  ctx.fillRect(0, 0, W, H*0.6);

  // Windshield glare (top-left streak)
  const glareG = ctx.createLinearGradient(W*0.08, 0, W*0.5, H*0.52);
  glareG.addColorStop(0, 'rgba(255,255,255,0.018)');
  glareG.addColorStop(0.6, 'rgba(255,255,255,0.006)');
  glareG.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = glareG;
  ctx.beginPath();
  ctx.moveTo(W*0.08, 0); ctx.lineTo(W*0.52, 0);
  ctx.lineTo(W*0.34, H*0.58); ctx.lineTo(W*0.09, H*0.65);
  ctx.closePath(); ctx.fill();
  ctx.restore();

  // ‚îÄ‚îÄ‚îÄ SPEED MOTION BLUR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (speedFrac > 0.6) {
    const blur = ctx.createRadialGradient(cx, H*0.45, H*0.07, cx, H*0.45, H*0.6);
    const intensity = (speedFrac - 0.6) * 0.45;
    blur.addColorStop(0, 'rgba(0,0,0,0)');
    blur.addColorStop(1, `rgba(0,0,10,${intensity})`);
    ctx.fillStyle = blur;
    ctx.fillRect(0, 0, W, H);
  }

  // ‚îÄ‚îÄ‚îÄ ABILITY ACTIVE PULSE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (player.abilityActive) {
    ctx.save();
    ctx.globalAlpha = 0.06 + Math.sin(now * 0.014) * 0.03;
    ctx.fillStyle = ac;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }
}


function drawMinimap() {
  mctx.clearRect(0, 0, 120, 120);
  const scale = 0.065;
  const offX = 60, offY = 60;

  mctx.strokeStyle = '#888';
  mctx.lineWidth = 6;
  mctx.beginPath();
  trackPoints.forEach((p, i) => {
    const mx = p.x * scale + offX, my = p.y * scale + offY;
    i === 0 ? mctx.moveTo(mx, my) : mctx.lineTo(mx, my);
  });
  mctx.closePath();
  mctx.stroke();

  karts.forEach(k => {
    const mx = k.x * scale + offX, my = k.y * scale + offY;
    mctx.beginPath();
    mctx.arc(mx, my, k.isPlayer ? 5 : 3, 0, Math.PI * 2);
    mctx.fillStyle = k.color;
    mctx.fill();
  });

  // Draw player direction arrow
  const mx = player.x * scale + offX, my = player.y * scale + offY;
  mctx.save();
  mctx.translate(mx, my);
  mctx.rotate(player.angle);
  mctx.fillStyle = '#f7c948';
  mctx.beginPath();
  mctx.moveTo(0, -7);
  mctx.lineTo(3, 3);
  mctx.lineTo(-3, 3);
  mctx.closePath();
  mctx.fill();
  mctx.restore();
}

// ===================== COUNTDOWN =====================
function drawCountdown(now) {
  const num = Math.ceil(countdown);
  if (num <= 0) return;
  const alpha = 1 - (countdownTimer % 1);
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.font = `bold ${Math.floor(200 + (1 - alpha) * 100)}px 'Russo One', sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = countdown <= 1 ? '#2ecc71' : '#f7c948';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 10;
  const label = countdown <= 0.5 ? 'GO!' : String(num);
  ctx.strokeText(label, W / 2, H / 2);
  ctx.fillText(label, W / 2, H / 2);
  ctx.restore();
}

// ===================== MAIN LOOP =====================
let lastTime = 0;
function loop(ts = 0) {
  animId = requestAnimationFrame(loop);
  const dt = lastTime === 0 ? 0 : Math.min((ts - lastTime) / 16.67, 3);
  lastTime = ts;

  // Countdown
  if (countdown > 0) {
    countdownTimer += dt * 0.04;
    countdown = Math.max(0, 3 - countdownTimer);
    if (countdown <= 0) raceStarted = true;
  }

  if (raceStarted) raceTime += dt * 16.67;

  if (raceStarted) {
    const dtMs = dt * 16.67;
    updatePlayer(dt);
    karts.filter(k => !k.isPlayer).forEach(k => updateCPU(k, dt));
    karts.forEach(updateLaps);
    updateParticles(dtMs);
  }

  // Camera: smoothly follow player (still used for minimap)
  camX = player.x; camY = player.y; camAngle = player.angle;

  ctx.clearRect(0, 0, W, H);

  // First-person 3D render
  drawFirstPerson();

  // Vignette overlay
  const vign = ctx.createRadialGradient(W/2, H/2, H*0.2, W/2, H/2, H*0.7);
  vign.addColorStop(0, 'rgba(0,0,0,0)');
  vign.addColorStop(1, 'rgba(0,0,0,0.45)');
  ctx.fillStyle = vign;
  ctx.fillRect(0, 0, W, H);

  drawCountdown(ts);
  drawMinimap();

  // HUD updates
  document.getElementById('speedDisplay').textContent = Math.abs(Math.round(player.speed * 12)) + ' km/h';
  document.getElementById('lapDisplay').textContent = `${Math.min(player.lap, TOTAL_LAPS)} / ${TOTAL_LAPS}`;
  document.getElementById('timeDisplay').textContent = formatTime(raceTime);
  document.getElementById('posDisplay').textContent = ordinals[getRacePosition() - 1];

  // Ability HUD
  const rosterK = KART_ROSTER[selectedKartIdx];
  document.getElementById('abilityIcon').textContent = rosterK.ability.icon;
  document.getElementById('abilityName').textContent = rosterK.ability.name;
  const elapsed = raceTime - player.abilityLastUsed;
  const cdFrac = Math.min(elapsed / player.abilityCooldown, 1);
  const fill = document.getElementById('abilityCooldownFill');
  fill.style.width = (cdFrac * 100) + '%';
  const statusEl = document.getElementById('abilityStatus');
  if (player.abilityActive) {
    fill.style.background = rosterK.accentColor;
    statusEl.textContent = 'ACTIVE!';
    statusEl.style.color = rosterK.accentColor;
  } else if (cdFrac >= 1) {
    fill.style.background = '#2ecc71';
    statusEl.textContent = 'READY ‚Äî Press E';
    statusEl.style.color = '#2ecc71';
  } else {
    fill.style.background = '#888';
    statusEl.textContent = `${((1 - cdFrac) * rosterK.ability.cooldown / 1000).toFixed(1)}s`;
    statusEl.style.color = '#888';
  }
}

// Camera (used for minimap)
let camX = 0, camY = 0, camAngle = 0;

buildTrack();
buildEdges();
// Just render static frame behind overlay
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Touch controls for mobile
const touchState = { steer: 0, accel: false, brake: false };
let touchStartX = 0;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0];
  touchStartX = t.clientX;
  if (t.clientY > window.innerHeight * 0.6) {
    keys['ArrowUp'] = true;
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  const dx = t.clientX - touchStartX;
  keys['ArrowLeft'] = dx < -20;
  keys['ArrowRight'] = dx > 20;
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  keys['ArrowUp'] = false;
  keys['ArrowLeft'] = false;
  keys['ArrowRight'] = false;
}, { passive: false });
</script>
</body>
</html>
